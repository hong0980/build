#!/bin/sh

. "$IPKG_INSTROOT/usr/share/libubox/jshn.sh"

action="$1"
shift

case "$action" in
    fsfdisk)
        sfdisk -F "$1" 2>/dev/null | awk '
        /Unpartitioned space/ {
            # 行1: "Unpartitioned space /dev/sdb: 55.58 GiB, 59678654976 bytes, 116559873 sectors"
            free_size = $4 " " $5;    # "55.58 GiB,"
            free_bytes = $6;          # "59678654976"
            free_sectors = $8;        # "116559873"
            gsub(/,/, "", free_size);
            gsub(/,/, "", free_bytes);
        }
        /^[0-9]/ && NF == 4 {
            # 行6: "4517888 121077760 116559873 55.6G"
            free_start = $1;
            free_end = $2;
            free_sectors_num = $3;
            free_size_h = $4;
        }
        END {
            if (free_sectors) {
                print "{";
                print "  \"free_space\": {";
                printf "    \"Size\": \"%s\",\n", free_size_h;
                printf "    \"size\": \"%s\",\n", free_size_h;
                printf "    \"size_bytes\": %s,\n", free_bytes;
                printf "    \"sectors\": %s,\n", free_sectors;
                printf "    \"start\": %s,\n", free_start;
                printf "    \"end\": %s\n", free_end;
                print "  }";
                print "}";
            }
        }'
    ;;
    lsfdisk)
        sfdisk -l "$1" 2>/dev/null | awk '
        function get_filesystem_type(id, type_desc) {
            # 根据分区ID和描述判断文件系统类型
            if (id == "83") return "ext4";
            if (id == "82") return "swap";
            if (id == "ef") return "fat32";
            if (id == "0") return "iso9660";
            if (id == "7") return "ntfs";
            if (id == "b" || id == "c") return "fat32";
            if (id == "1" || id == "4" || id == "6" || id == "e") return "fat16";
            if (id == "85") return "extended";
            if (id == "5" || id == "f") return "extended";

            # 根据类型描述判断
            if (type_desc ~ /FAT-12/) return "fat12";
            if (type_desc ~ /FAT-16/) return "fat16";
            if (type_desc ~ /FAT-32/) return "fat32";
            if (type_desc ~ /FAT/) return "fat";
            if (type_desc ~ /Linux/) return "ext4";
            if (type_desc ~ /swap/) return "swap";
            if (type_desc ~ /NTFS/) return "ntfs";
            if (type_desc ~ /ext4/) return "ext4";
            if (type_desc ~ /ext3/) return "ext3";
            if (type_desc ~ /ext2/) return "ext2";
            if (type_desc ~ /ISO/) return "iso9660";
            if (type_desc ~ /Empty/) return "iso9660";
            if (type_desc ~ /EFI/) return "fat32";

            return "";
        }

        BEGIN {
            print "  {";
            print "    \"disk\": {";
            first_part = 1;
            disk_fields_added = 0;
        }

        /^Disk \/dev\// {
            # Disk /dev/sdb: 57.73 GiB, 61991813632 bytes, 121077761 sectors
            path = $2; gsub(/:/, "", path);
            size_value = $3;
            size_unit = $4;
            gsub(/,/, "", size_unit);

            printf "      \"device\": \"%s\",\n", path;
            printf "      \"size\": \"%s %s\",\n", size_value, size_unit;
            printf "      \"total_sectors\": %s", $7;
            disk_fields_added = 1;
            next;
        }

        /^Disk model:/ {
            # Disk model: DataTraveler 3.0
            sub(/^Disk model:[[:space:]]*/, "", $0)
            if (disk_fields_added) {
                printf ",\n      \"model\": \"%s\"", $0
            } else {
                printf "      \"model\": \"%s\"", $0
            }
            next
        }

        /^Disklabel type:/ {
            # Disklabel type: dos
            printf ",\n      \"partition_table\": \"%s\"", $3;
            next;
        }

        /Sector.*size/ {
            # Sector size (logical/physical): 512 bytes / 512 bytes
            match($0, /([0-9]+) bytes.*\/([0-9]+) bytes/, arr)
            if (arr[1] != "") {
                logical_sector = arr[1] + 0
                physical_sector = (arr[2] != "" ? arr[2] + 0 : logical_sector)
            }
            next
        }

        /^\/dev\// && !/^Device/ {
            if (first_part) {
                printf ",\n      \"sector_size\": {\n";
                printf "        \"logical\": %d,\n", logical_sector;
                printf "        \"physical\": %d\n", physical_sector;
                printf "      }";
                printf "\n    },\n";
                printf "    \"partitions\": [";
                first_part = 0;
            } else {
                printf ",\n";
            }

            # 清理和分割字段
            gsub(/  +/, " ", $0);
            gsub(/^ /, "", $0);
            n = split($0, fields, " ");

            # 检查启动标记
            has_boot = (fields[2] == "*") ? 1 : 0;
            start_idx = 2 + has_boot;


            # 清理数字字段
            for (i = start_idx; i <= start_idx + 2; i++) {
                gsub(/[^0-9]/, "", fields[i]);
                fields[i] = fields[i] + 0;  # 转换为数字
            }
            sub(/.*[^0-9]/, "", fields[1])

            printf "      {\n";
            printf "        \"number\": %d,\n", fields[1];
            printf "        \"start\": %d,\n", fields[start_idx];
            printf "        \"end\": %d,\n", fields[start_idx + 1];
            printf "        \"size\": %d,\n", fields[start_idx + 2];
            printf "        \"Size\": \"%s\",\n", fields[start_idx + 3];
            printf "        \"type\": \"primary\",\n";

            # 合并类型描述
            type_desc = "";
            for (i = start_idx + 5; i <= n; i++) {
                type_desc = type_desc (type_desc ? " " : "") fields[i];
            }

            # 清理ID字段
            id = fields[start_idx + 4];
            gsub(/[^0-9a-fA-F]/, "", id);

            printf "        \"fileSystem\": \"%s\"\n", get_filesystem_type(id, type_desc);
            printf "      }";
            next;
        }

        END {
            if (first_part) {
                # 没有分区的情况
                printf ",\n      \"sector_size\": {\n";
                printf "        \"logical\": %d,\n", logical_sector;
                printf "        \"physical\": %d\n", physical_sector;
                printf "      }";
                printf "\n    },\n";
                printf "    \"partitions\": []\n";
            } else {
                printf "\n    ]\n";
            }
            print "  }";
        }'
    ;;
    mount_dev)
        dev="$1"
        mp="$2"

        mkdir -p "$mp"

        case $(blkid -o value -s TYPE "$dev" 2>/dev/null) in
            udf|iso9660)
                opts="ro,noatime"
                ;;
            ntfs)
                opts="rw,noatime,uid=0,gid=0,dmask=000,fmask=111"
                ;;
            vfat|exfat)
                opts="rw,noatime,utf8=1,flush,uid=0,gid=0,dmask=000,fmask=111"
                ;;
            "")
                echo "无法确定 $dev 的文件系统类型"
                rmdir "$mp" 2>/dev/null
                exit 1
                ;;
            *)
                opts="rw,noatime"
                ;;
        esac

        if mount -o "$opts" "$dev" "$mp" 2>&1; then
            echo "__OK__"
            exit 0
        else
            rmdir "$mp" 2>/dev/null
            exit 1
        fi
    ;;
    df)
        /bin/df -h | awk '
        NR==1 {for(i=1;i<=NF;i++) h[i]=$i; print "["; next}
        NF>=6 {
            printf "%s{\n", (NR>2 ? "," : "")
            mount=$6; for(i=7;i<=NF;i++) mount=mount" "$i
            gsub(/"/, "\\\"", mount)
            printf "  \"%s\":\"%s\",\n  \"%s\":\"%s\",\n  \"%s\":\"%s\",\n  \"%s\":\"%s\",\n  \"%s\":\"%s\",\n  \"%s\":\"%s\"\n}", h[1],$1,h[2],$2,h[3],$3,h[4],$4,h[5],$5,h[6],mount
        }
        END {print "]"}'
    ;;
    mount_info)
        /bin/mount | awk '
        BEGIN {print "["; first=1}
        {
            options = ""
            for (i=6;i<=NF;i++) options = options (i==6?"":" ") $i
            gsub(/^\(|\)$/, "", options)
            gsub(/"/, "\\\"", options)

            if (!first) printf ","
            printf "{\n  \"device\":\"%s\",\n  \"mount_point\":\"%s\",\n  \"filesystem\":\"%s\",\n  \"options\":\"%s\"\n}", $1, $3, $5, options
            first=0
        }
        END {print "]"}'
    ;;
    parted)
        /sbin/parted -s "$1" unit s print free | awk '
        BEGIN {print "{"; disk_printed = 0; first_part = 1}

        /^Model:/ {
            model = substr($0, 7)
            sub(/^ /, "", model)
        }

        /^Disk \/dev\// {
            device = $2
            sub(/:$/, "", device)
            total_sectors = $3
            sub(/s$/, "", total_sectors)
        }

        /Sector size/ {
            # Sector size (logical/physical): 512B/512B
            if (match($0, /([0-9]+)B\/([0-9]+)B/)) {
                logical = substr($0, RSTART, RLENGTH)
                split(logical, arr, "/")
                logical = arr[1]
                physical = arr[2]
                sub(/B/, "", logical)
                sub(/B/, "", physical)
            }
        }

        /Partition Table:/ {
            pt = $3
        }

        /Disk Flags:/ {
            flags = substr($0, 12)
            sub(/^[ ]*/, "", flags)
            if (flags == "") flags = ""

            # 输出磁盘信息
            print "  \"disk\": {"
            printf "    \"model\": \"%s\",\n", model
            printf "    \"device\": \"%s\",\n", device
            printf "    \"total_sectors\": %s,\n", total_sectors
            print "    \"sector_size\": {"
            printf "      \"logical\": %s,\n", logical
            printf "      \"physical\": %s\n", physical
            print "    },"
            printf "    \"partition_table\": \"%s\",\n", pt
            printf "    \"flags\": \"%s\"\n", flags
            print "  },"
            print "  \"partitions\": ["
            disk_printed = 1
        }

        # 只在磁盘信息输出后处理分区
        disk_printed && (/^[[:space:]]*[0-9]+s/ || /^[[:space:]]*[0-9]+[[:space:]]+[0-9]+s/) {
            if (!first_part) {
                printf ",\n"
            }
            first_part = 0

            if ($1 ~ /^[0-9]+$/) {
                # 正常分区
                type = ""
                number = $1; start = $2; end = $3; size = $4; fs = $5; flags_val = "";
                if (pt == "msdos") {
                    type = $5; fs = $6; flags_val = ($7 == "" ? "" : $7)
                }

                # 移除's'后缀
                sub(/s$/, "", start)
                sub(/s$/, "", end)
                sub(/s$/, "", size)

                printf "    {\"number\": %d, \"start\": \"%s\", \"end\": \"%s\", \"size\": \"%s\", \"type\": \"%s\", \"fileSystem\": \"%s\", \"flags\": \"%s\"}", number, start, end, size, type, fs, flags_val
            } else {
                # Free Space
                start = $1; end = $2; size = $3; fs = substr($0, index($0, $4));

                # 移除's'后缀
                sub(/s$/, "", start)
                sub(/s$/, "", end)
                sub(/s$/, "", size)

                printf "    {\"number\": null, \"start\": \"%s\", \"end\": \"%s\", \"size\": \"%s\", \"fileSystem\": \"%s\"}", start, end, size, fs
            }
        }

        END {
            if (disk_printed) {
                print "\n  ]\n}"
            } else {
                print "}"
            }
        }'
    ;;
    rescandisks)
        echo '- - -' | tee /sys/class/scsi_host/host*/scan > /dev/null && return 0 || return 1
        /usr/bin/which mdadm > /dev/null && mdadm --assemble --scan
    ;;
    reject)
        device_name="$1"
        devpath="$2"
        devtype="$3"

        if grep "^$devpath" /proc/mounts | grep -qvE ' squashfs .* /rom | vfat | exfat | ntfs | fuseblk | iso9660 '; then
            echo "错误：设备 $devpath 正被内核真正占用，无法弹出！"
            # echo "挂载情况："
            # grep "^$devpath" /proc/mounts | awk '{print "  "$1" -> "$2" ("$3")"}'
            exit 1
        fi

        if [ "$devtype" = "disk" ]; then
            if echo 1 > "/sys/block/$device_name/device/delete" 2>/dev/null; then
                echo "磁盘 $devpath 已安全弹出"
            else
                echo "磁盘 $devpath 弹出失败（可能为系统盘或仍在使用）"
                exit 1
            fi
            exit 0
        fi
        if echo "$device_name" | grep -Eq '^md[0-9]+'; then
            mdadm --stop "/dev/$device_name" 2>/dev/null
            mdadm --remove "/dev/$device_name" 2>/dev/null || true
            echo "RAID 阵列 /dev/$device_name 已停止并移除"
            exit 0
        fi

        echo "不支持的设备类型：$devtype"
        exit 1
    ;;
esac
