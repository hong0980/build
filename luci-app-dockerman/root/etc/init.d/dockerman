#!/bin/sh /etc/rc.common
# OpenWrt init脚本：管理Docker容器的端口白名单和防火墙规则

START=99          # 服务启动顺序，数值越大越晚启动（确保Docker已完全启动）
USE_PROCD=1       # 使用procd进程管理框架管理服务
# PROCD_DEBUG=1     # 启用调试模式（取消注释后生效）

DOCKERD_INIT_SCRIPT=/etc/init.d/dockerd  # Docker守护进程的init脚本路径
DOCKERD_CONFIG=dockerd                   # 配置文件的UCI节点名称

# 检查Docker是否正在运行
# 返回值：0（运行中）/非0（未运行）
docker_is_running() {
	docker version &>/dev/null  # 尝试执行docker version命令
	return $?  # 返回命令执行状态
}

# 将指定容器的端口添加到UCI配置的白名单
# 参数：容器ID列表
add_allowed_container_ports() {
	local container_ids=("$@")  # 存储传入的容器ID列表
	[ ${#container_ids[@]} -eq 0 ] && return  # 无参数时直接返回

	config_load "$DOCKERD_CONFIG"  # 加载配置文件
	docker_is_running || return 1  # 检查Docker是否运行，失败则返回

	for cid in "${container_ids[@]}"; do
		# 获取运行中的容器ID（过滤非运行中的容器）
		cid=$(docker ps --filter "id=$cid" --quiet)
		[ -z "$cid" ] && {  # 如果容器未运行
			echo "容器 $cid 未运行" >&2
			return 1
		}

		# 解析容器的端口映射（格式：HostPort/Protocol）
		ports=$(docker inspect --format='{{range .NetworkSettings.Ports}}{{printf "%s/%s " (index .HostPort) (index .Type)}}{{end}}' "$cid")
		for port in $ports; do
			uci_add_list "$DOCKERD_CONFIG" dockerman ac_allowed_ports "$port"  # 将端口添加到白名单
		done
	done
	uci_commit "$DOCKERD_CONFIG"  # 提交配置更改
}

# 将旧的容器ID配置转换为基于端口的白名单
convert_old_config() {
	config_load "$DOCKERD_CONFIG"  # 加载配置文件
	config_foreach convert_container ac_allowed_container  # 遍历旧容器ID列表
}

# 处理单个旧容器ID的转换
convert_container() {
	local container_id=$1  # 接收容器ID
	local cid=$(docker inspect --format='{{.Id}}' "$container_id" 2>/dev/null)  # 获取容器实际ID

	# 如果容器不存在，从旧配置中移除该ID
	[ -z "$cid" ] && uci_delete "$DOCKERD_CONFIG.@dockerman[0].ac_allowed_container.$container_id"

	# 如果Docker运行且成功添加端口，移除旧配置项
	if docker_is_running && add_allowed_container_ports "$cid"; then
		uci_delete "$DOCKERD_CONFIG.@dockerman[0].ac_allowed_container.$container_id"
	fi
}

# 安全添加iptables规则（避免重复）
# 参数：iptables命令参数
iptables_append() {
	local args="--wait 10 --wait-interval 1000"  # 设置等待参数（最多10秒，间隔1ms）
	# 检查规则是否存在，不存在则追加
	iptables $args -C "$@" &>/dev/null || iptables $args -A "$@"
}

# 初始化DOCKER-MAN链（用于Docker端口白名单）
init_firewall_chain() {
	iptables -N DOCKER-MAN &>/dev/null  # 创建新链（忽略错误）
	iptables -F DOCKER-MAN &>/dev/null  # 清空链中现有规则
	iptables -D DOCKER-USER -j DOCKER-MAN &>/dev/null  # 删除旧跳转规则
	iptables -I DOCKER-USER -j DOCKER-MAN &>/dev/null  # 在DOCKER-USER链顶部插入跳转规则
}

# 清理DOCKER-MAN链
cleanup_firewall_chain() {
	iptables -D DOCKER-USER -j DOCKER-MAN &>/dev/null  # 删除跳转规则
	iptables -F DOCKER-MAN &>/dev/null  # 清空链规则
	iptables -X DOCKER-MAN &>/dev/null  # 删除链
}

# 应用允许的网络接口规则
apply_allowed_interfaces() {
	config_list_foreach dockerman ac_allowed_interface add_allowed_interface  # 遍历接口列表添加规则

	# 允许已建立的连接通过docker0
	iptables_append DOCKER-MAN -m conntrack --ctstate ESTABLISHED,RELATED -o docker0 -j RETURN
	# 拦截新的未授权连接
	iptables_append DOCKER-MAN -m conntrack --ctstate NEW,INVALID -o docker0 -j DROP
	# 规则结束（返回主链）
	iptables_append DOCKER-MAN -j RETURN
}

# 应用允许的端口白名单规则
apply_allowed_ports() {
	config_list_foreach dockerman ac_allowed_ports add_allowed_port  # 遍历端口列表添加规则
}

# 添加单个端口到iptables规则
add_allowed_port() {
	local port=$1  # 接收端口（格式：Port/Protocol）
	local proto=${port##*/}  # 提取协议（tcp/udp）
	local num=${port%/*}  # 提取端口号

	case "$proto" in
		tcp)  # 处理TCP端口
			iptables_append DOCKER-MAN -p tcp -m conntrack --ctorigdstport "$num" --ctdir ORIGINAL -j RETURN ;;
		udp)  # 处理UDP端口
			iptables_append DOCKER-MAN -p udp -m conntrack --ctorigdstport "$num" --ctdir ORIGINAL -j RETURN ;;
		*) return ;;  # 无效协议跳过
	esac
}

# 启动服务时初始化规则
start_service() {
	# 检查Docker守护进程是否存在且已启用
	[ ! -x "$DOCKERD_INIT_SCRIPT" ] && return
	$DOCKERD_INIT_SCRIPT enabled || return
	docker_is_running || return  # 确保Docker正在运行

	cleanup_firewall_chain  # 清理旧规则
	init_firewall_chain     # 初始化新链
	apply_allowed_ports     # 应用端口白名单
	apply_allowed_interfaces  # 应用接口白名单
}

# 停止服务时清理规则
stop_service() {
	cleanup_firewall_chain  # 移除所有相关规则
}

# 系统启动时执行初始化
boot() {
	sleep 5  # 等待Docker初始化完成
	start_service  # 启动服务
}

# 自定义命令注册
extra_command "add_ports" "Add allowed ports for containers" add_allowed_container_ports
extra_command "convert" "Convert old container IDs to port rules" convert_old_config
