"use strict";

function DEFNODE(a, b, c, d) {
    var e, f, g, h, i;
    for (arguments.length < 4 && (d = AST_Node), b = b ? b.split(/\s+/) : [], e = b, d && d.PROPS && (b = b.concat(d.PROPS)), f = "return function AST_" + a + "(props){ if (props) { ", g = b.length; --g >= 0;) f += "this." + b[g] + " = props." + b[g] + ";";
    if (h = d && new d, (h && h.initialize || c && c.initialize) && (f += "this.initialize();"), f += "}}", i = new Function(f)(), h && (i.prototype = h, i.BASE = d), d && d.SUBCLASSES.push(i), i.prototype.CTOR = i, i.PROPS = b || null, i.SELF_PROPS = e, i.SUBCLASSES = [], a && (i.prototype.TYPE = i.TYPE = a), c)
        for (g in c) c.hasOwnProperty(g) && (/^\$/.test(g) ? i[g.substr(1)] = c[g] : i.prototype[g] = c[g]);
    return i.DEFMETHOD = function (a, b) {
        this.prototype[a] = b
    }, i
}

function walk_body(a, b) {
    a.body instanceof AST_Statement ? a.body._walk(b) : a.body.forEach(function (a) {
        a._walk(b)
    })
}

function TreeWalker(a) {
    this.visit = a, this.stack = []
}

function OutputStream(a) {
    function g(a, b) {
        return a.replace(/[\u0080-\uffff]/g, function (a) {
            var c = a.charCodeAt(0).toString(16);
            if (c.length <= 2 && !b) {
                for (; c.length < 2;) c = "0" + c;
                return "\\x" + c
            }
            for (; c.length < 4;) c = "0" + c;
            return "\\u" + c
        })
    }

    function h(b) {
        var c = 0,
            d = 0;
        return b = b.replace(/[\\\b\f\n\r\t\x22\x27\u2028\u2029\0]/g, function (a) {
            switch (a) {
                case "\\":
                    return "\\\\";
                case "\b":
                    return "\\b";
                case "\f":
                    return "\\f";
                case "\n":
                    return "\\n";
                case "\r":
                    return "\\r";
                case "\u2028":
                    return "\\u2028";
                case "\u2029":
                    return "\\u2029";
                case '"':
                    return ++c, '"';
                case "'":
                    return ++d, "'";
                case "\0":
                    return "\\x00"
            }
            return a
        }), a.ascii_only && (b = g(b)), c > d ? "'" + b.replace(/\x27/g, "\\'") + "'" : '"' + b.replace(/\x22/g, '\\"') + '"'
    }

    function i(b) {
        var c = h(b);
        return a.inline_script && (c = c.replace(/<\x2fscript([>\/\t\n\f\r ])/gi, "<\\/script$1")), c
    }

    function j(b) {
        return b = b.toString(), a.ascii_only && (b = g(b, !0)), b
    }

    function k(c) {
        return repeat_string(" ", a.indent_start + b - c * a.indent_level)
    }

    function o() {
        return n.charAt(n.length - 1)
    }

    function p() {
        a.max_line_len && c > a.max_line_len && r("\n")
    }

    function r(b) {
        var g, h, i, j, k;
        if (b = String(b), g = b.charAt(0), m && (g && !(";}".indexOf(g) < 0) || /[;]$/.test(n) || (a.semicolons || q(g) ? (f += ";", c++, e++) : (f += "\n", e++, d++, c = 0), a.beautify || (l = !1)), m = !1, p()), !a.beautify && a.preserve_line && G[G.length - 1])
            for (h = G[G.length - 1].start.line; h > d;) f += "\n", e++, d++, c = 0, l = !1;
        l && (i = o(), (is_identifier_char(i) && (is_identifier_char(g) || "\\" == g) || /^[\+\-\/]$/.test(g) && g == i) && (f += " ", c++, e++), l = !1), j = b.split(/\r?\n/), k = j.length - 1, d += k, 0 == k ? c += j[k].length : c = j[k].length, e += b.length, n = b, f += b
    }

    function x() {
        m = !1, r(";")
    }

    function y() {
        return b + a.indent_level
    }

    function z(a) {
        var b;
        return r("{"), v(), u(y(), function () {
            b = a()
        }), t(), r("}"), b
    }

    function A(a) {
        r("(");
        var b = a();
        return r(")"), b
    }

    function B(a) {
        r("[");
        var b = a();
        return r("]"), b
    }

    function C() {
        r(","), s()
    }

    function D() {
        r(":"), a.space_colon && s()
    }

    function F() {
        return f
    }
    var b, c, d, e, f, l, m, n, q, s, t, u, v, w, E, G;
    return a = defaults(a, {
        indent_start: 0,
        indent_level: 4,
        quote_keys: !1,
        space_colon: !0,
        ascii_only: !1,
        unescape_regexps: !1,
        inline_script: !1,
        width: 80,
        max_line_len: 32e3,
        beautify: !1,
        source_map: null,
        bracketize: !1,
        semicolons: !0,
        comments: !1,
        preserve_line: !1,
        screw_ie8: !1,
        preamble: null
    }, !0), b = 0, c = 0, d = 1, e = 0, f = "", l = !1, m = !1, n = null, q = makePredicate("( [ + * / - , ."), s = a.beautify ? function () {
        r(" ")
    } : function () {
        l = !0
    }, t = a.beautify ? function (b) {
        a.beautify && r(k(b ? .5 : 0))
    } : noop, u = a.beautify ? function (a, c) {
        var d, e;
        return a === !0 && (a = y()), d = b, b = a, e = c(), b = d, e
    } : function (a, b) {
        return b()
    }, v = a.beautify ? function () {
        r("\n")
    } : noop, w = a.beautify ? function () {
        r(";")
    } : function () {
        m = !0
    }, E = a.source_map ? function (b, e) {
        try {
            b && a.source_map.add(b.file || "?", d, c, b.line, b.col, e || "name" != b.type ? e : b.value)
        } catch (f) {
            AST_Node.warn("无法找出 {file} 的映射：{line},{col} → {cline},{ccol} [{name}]", {
                file: b.file,
                line: b.line,
                col: b.col,
                cline: d,
                ccol: c,
                name: e || ""
            })
        }
    } : noop, a.preamble && r(a.preamble.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g, "\n")), G = [], {
        get: F,
        toString: F,
        indent: t,
        indentation: function () {
            return b
        },
        current_width: function () {
            return c - b
        },
        should_break: function () {
            return a.width && this.current_width() >= a.width
        },
        newline: v,
        print: r,
        space: s,
        comma: C,
        colon: D,
        last: function () {
            return n
        },
        semicolon: w,
        force_semicolon: x,
        to_ascii: g,
        print_name: function (a) {
            r(j(a))
        },
        print_string: function (a) {
            r(i(a))
        },
        next_indent: y,
        with_indent: u,
        with_block: z,
        with_parens: A,
        with_square: B,
        add_mapping: E,
        option: function (b) {
            return a[b]
        },
        line: function () {
            return d
        },
        col: function () {
            return c
        },
        pos: function () {
            return e
        },
        push_node: function (a) {
            G.push(a)
        },
        pop_node: function () {
            return G.pop()
        },
        stack: function () {
            return G
        },
        parent: function (a) {
            return G[G.length - 2 - (a || 0)]
        }
    }
}

function is_letter(a) {
    return a >= 97 && 122 >= a || a >= 65 && 90 >= a || a >= 170 && UNICODE.letter.test(String.fromCharCode(a))
}

function is_digit(a) {
    return a >= 48 && 57 >= a
}

function is_alphanumeric_char(a) {
    return is_digit(a) || is_letter(a)
}

function is_unicode_combining_mark(a) {
    return UNICODE.non_spacing_mark.test(a) || UNICODE.space_combining_mark.test(a)
}

function is_unicode_connector_punctuation(a) {
    return UNICODE.connector_punctuation.test(a)
}

function is_identifier(a) {
    return !RESERVED_WORDS(a) && /^[a-z_$][a-z0-9_$]*$/i.test(a)
}

function is_identifier_start(a) {
    return 36 == a || 95 == a || is_letter(a)
}

function is_identifier_char(a) {
    var b = a.charCodeAt(0);
    return is_identifier_start(b) || is_digit(b) || 8204 == b || 8205 == b || is_unicode_combining_mark(a) || is_unicode_connector_punctuation(a)
}

function is_identifier_string(a) {
    return /^[a-z_$][a-z0-9_$]*$/i.test(a)
}

function parse_js_number(a) {
    return RE_HEX_NUMBER.test(a) ? parseInt(a.substr(2), 16) : RE_OCT_NUMBER.test(a) ? parseInt(a.substr(1), 8) : RE_DEC_NUMBER.test(a) ? parseFloat(a) : void 0
}

function JS_Parse_Error(a, b, c, d) {
    this.message = a, this.line = b, this.col = c, this.pos = d, this.stack = (new Error).stack
}

function js_error(a, b, c, d, e) {
    throw new JS_Parse_Error(a, c, d, e)
}

function is_token(a, b, c) {
    return a.type == b && (null == c || a.value == c)
}

function tokenizer(a, b, c) {
    function e() {
        return d.text.charAt(d.pos)
    }

    function f(a, b) {
        var c = d.text.charAt(d.pos++);
        if (a && !c) throw EX_EOF;
        return "\n" == c ? (d.newline_before = d.newline_before || !b, ++d.line, d.col = 0) : ++d.col, c
    }

    function g(a) {
        for (; a-- > 0;) f()
    }

    function h(a) {
        return d.text.substr(d.pos, a.length) == a
    }

    function i(a, b) {
        var c = d.text.indexOf(a, d.pos);
        if (b && -1 == c) throw EX_EOF;
        return c
    }

    function j() {
        d.tokline = d.line, d.tokcol = d.col, d.tokpos = d.pos
    }

    function l(a, c, e) {
        var f, g, h;
        if (d.regex_allowed = "operator" == a && !UNARY_POSTFIX(c) || "keyword" == a && KEYWORDS_BEFORE_EXPRESSION(c) || "punc" == a && PUNC_BEFORE_EXPRESSION(c), k = "punc" == a && "." == c, f = {
            type: a,
            value: c,
            line: d.tokline,
            col: d.tokcol,
            pos: d.tokpos,
            endpos: d.pos,
            nlb: d.newline_before,
            file: b
        }, !e)
            for (f.comments_before = d.comments_before, d.comments_before = [], g = 0, h = f.comments_before.length; h > g; g++) f.nlb = f.nlb || f.comments_before[g].nlb;
        return d.newline_before = !1, new AST_Token(f)
    }

    function m() {
        for (; WHITESPACE_CHARS(e());) f()
    }

    function n(a) {
        for (var c, b = "", d = 0;
            (c = e()) && a(c, d++);) b += f();
        return b
    }

    function o(a) {
        js_error(a, b, d.tokline, d.tokcol, d.tokpos)
    }

    function p(a) {
        var g, b = !1,
            c = !1,
            d = !1,
            e = "." == a,
            f = n(function (f, g) {
                var h = f.charCodeAt(0);
                switch (h) {
                    case 120:
                    case 88:
                        return d ? !1 : d = !0;
                    case 101:
                    case 69:
                        return d ? !0 : b ? !1 : b = c = !0;
                    case 45:
                        return c || 0 == g && !a;
                    case 43:
                        return c;
                    case c = !1, 46:
                        return e || d || b ? !1 : e = !0
                }
                return is_alphanumeric_char(h)
            });
        return a && (f = a + f), g = parse_js_number(f), isNaN(g) ? (o("无效的语法: " + f), void 0) : l("num", g)
    }

    function q(a) {
        var b = f(!0, a);
        switch (b.charCodeAt(0)) {
            case 110:
                return "\n";
            case 114:
                return "\r";
            case 116:
                return " ";
            case 98:
                return "\b";
            case 118:
                return "";
            case 102:
                return "\f";
            case 48:
                return "\0";
            case 120:
                return String.fromCharCode(r(2));
            case 117:
                return String.fromCharCode(r(4));
            case 10:
                return "";
            default:
                return b
        }
    }

    function r(a) {
        for (var c, b = 0; a > 0; --a) c = parseInt(f(!0), 16), isNaN(c) && o("字符串中的十六进制字符模式无效"), b = b << 4 | c;
        return b
    }

    function t(a) {
        var e, b = d.regex_allowed,
            c = i("\n");
        return -1 == c ? (e = d.text.substr(d.pos), d.pos = d.text.length) : (e = d.text.substring(d.pos, c), d.pos = c), d.comments_before.push(l(a, e, !0)), d.regex_allowed = b, C()
    }

    function v() {
        for (var c, g, a = !1, b = "", d = !1; null != (c = e());)
            if (a) "u" != c && o("需要 UnicodeEscapeSequence -- uXXXX"), c = q(), is_identifier_char(c) || o("Unicode 字符：" + c.charCodeAt(0) + " 在标识符中无效"), b += c, a = !1;
            else if ("\\" == c) d = a = !0, f();
            else {
                if (!is_identifier_char(c)) break;
                b += f()
            }
        return KEYWORDS(b) && d && (g = b.charCodeAt(0).toString(16).toUpperCase(), b = "\\u" + "0000".substr(g.length) + g + b.slice(1)), b
    }

    function x(a) {
        function b(a) {
            if (!e()) return a;
            var c = a + e();
            return OPERATORS(c) ? (f(), b(c)) : a
        }
        return l("operator", b(a || f()))
    }

    function y() {
        switch (f(), e()) {
            case "/":
                return f(), t("comment1");
            case "*":
                return f(), u()
        }
        return d.regex_allowed ? w("") : x("/")
    }

    function z() {
        return f(), is_digit(e().charCodeAt(0)) ? p(".") : l("punc", ".")
    }

    function A() {
        var a = v();
        return k ? l("name", a) : KEYWORDS_ATOM(a) ? l("atom", a) : KEYWORDS(a) ? OPERATORS(a) ? l("operator", a) : l("keyword", a) : l("name", a)
    }

    function B(a, b) {
        return function (c) {
            try {
                return b(c)
            } catch (d) {
                if (d !== EX_EOF) throw d;
                o(a)
            }
        }
    }

    function C(a) {
        var b, i;
        if (null != a) return w(a);
        if (m(), j(), c) {
            if (h("<!--")) return g(4), t("comment3");
            if (h("-->") && d.newline_before) return g(3), t("comment4")
        }
        if (b = e(), !b) return l("eof");
        switch (i = b.charCodeAt(0)) {
            case 34:
            case 39:
                return s();
            case 46:
                return z();
            case 47:
                return y()
        }
        return is_digit(i) ? p() : PUNC_CHARS(b) ? l("punc", f()) : OPERATOR_CHARS(b) ? x() : 92 == i || is_identifier_start(i) ? A() : (o("Unexpected character '" + b + "'"), void 0)
    }
    var d = {
        text: a.replace(/\r\n?|[\n\u2028\u2029]/g, "\n").replace(/\uFEFF/g, ""),
        filename: b,
        pos: 0,
        tokpos: 0,
        line: 1,
        tokline: 0,
        col: 0,
        tokcol: 0,
        newline_before: !1,
        regex_allowed: !1,
        comments_before: []
    },
        k = !1,
        s = B("未终止的字符串常量", function () {
            for (var c, d, e, a = f(), b = ""; ;) {
                if (c = f(!0), "\\" == c) d = 0, e = null, c = n(function (a) {
                    if (a >= "0" && "7" >= a) {
                        if (!e) return e = a, ++d;
                        if ("3" >= e && 2 >= d) return ++d;
                        if (e >= "4" && 1 >= d) return ++d
                    }
                    return !1
                }), c = d > 0 ? String.fromCharCode(parseInt(c, 8)) : q(!0);
                else if (c == a) break;
                b += c
            }
            return l("string", b)
        }),
        u = B("未终止的多行注释", function () {
            var g, a = d.regex_allowed,
                b = i("*/", !0),
                c = d.text.substring(d.pos, b),
                e = c.split("\n"),
                f = e.length;
            return d.pos = b + 2, d.line += f - 1, f > 1 ? d.col = e[f - 1].length : d.col += e[f - 1].length, d.col += 2, g = d.newline_before = d.newline_before || c.indexOf("\n") >= 0, d.comments_before.push(l("comment2", c, !0)), d.regex_allowed = a, d.newline_before = g, C()
        }),
        w = B("未终止的正则表达式", function (a) {
            for (var c, e, b = !1, d = !1; c = f(!0);)
                if (b) a += "\\" + c, b = !1;
                else if ("[" == c) d = !0, a += c;
                else if ("]" == c && d) d = !1, a += c;
                else {
                    if ("/" == c && !d) break;
                    "\\" == c ? b = !0 : a += c
                }
            return e = v(), l("regexp", new RegExp(a, e))
        });
    return C.context = function (a) {
        return a && (d = a), d
    }, C
}

function parse(a, b) {
    function d(a, b) {
        return is_token(c.token, a, b)
    }

    function e() {
        return c.peeked || (c.peeked = c.input())
    }

    function f() {
        return c.prev = c.token, c.peeked ? (c.token = c.peeked, c.peeked = null) : c.token = c.input(), c.in_directives = c.in_directives && ("string" == c.token.type || d("punc", ";")), c.token
    }

    function g() {
        return c.prev
    }

    function h(a, b, d, e) {
        var f = c.input.context();
        js_error(a, f.filename, null != b ? b : f.tokline, null != d ? d : f.tokcol, null != e ? e : f.tokpos)
    }

    function i(a, b) {
        h(b, a.line, a.col)
    }

    function j(a) {
        null == a && (a = c.token), i(a, "出现意外的符号: " + a.type + " (" + a.value + ")")
    }

    function k(a, b) {
        return d(a, b) ? f() : (i(c.token, "出现意外的符号 " + c.token.type + " «" + c.token.value + "»" + "，期望 " + a + " «" + b + "»"), void 0)

    }

    function l(a) {
        return k("punc", a)
    }

    function m() {
        return !b.strict && (c.token.nlb || d("eof") || d("punc", "}"))
    }

    function n() {
        d("punc", ";") ? f() : m() || j()
    }

    function o() {
        l("(");
        var a = Y(!0);
        return l(")"), a
    }

    function p(a) {
        return function () {
            var b = c.token,
                d = a(),
                e = g();
            return d.start = b, d.end = e, d
        }
    }

    function q() {
        (d("operator", "/") || d("operator", "/=")) && (c.peeked = null, c.token = c.input(c.token.value.substr(1)))
    }

    function s() {
        var b, a = P(AST_Label);
        return find_if(function (b) {
            return b.name == a.name
        }, c.labels) && h("Label " + a.name + " defined twice"), l(":"), c.labels.push(a), b = r(), c.labels.pop(), b instanceof AST_IterationStatement || a.references.forEach(function (b) {
            b instanceof AST_Continue && (b = b.label.start, h("Continue label `" + a.name + "` refers to non-IterationStatement.", b.line, b.col, b.pos))
        }), new AST_LabeledStatement({
            body: b,
            label: a
        })
    }

    function t(a) {
        return new AST_SimpleStatement({
            body: (a = Y(!0), n(), a)
        })
    }

    function u(a) {
        var d, e, b = null;
        return m() || (b = P(AST_LabelRef, !0)), null != b ? (d = find_if(function (a) {
            return a.name == b.name
        }, c.labels), d || h("Undefined label " + b.name), b.thedef = d) : 0 == c.in_loop && h(a.TYPE + " not inside a loop or switch"), n(), e = new a({
            label: b
        }), d && d.references.push(e), e
    }

    function v() {
        l("(");
        var a = null;
        return !d("punc", ";") && (a = d("keyword", "var") ? (f(), E(!0)) : Y(!0, !0), d("operator", "in")) ? (a instanceof AST_Var && a.definitions.length > 1 && h("for..in 循环中只允许声明一个变量"), f(), x(a)) : w(a)
    }

    function w(a) {
        var b, c;
        return l(";"), b = d("punc", ";") ? null : Y(!0), l(";"), c = d("punc", ")") ? null : Y(!0), l(")"), new AST_For({
            init: a,
            condition: b,
            step: c,
            body: Z(r)
        })
    }

    function x(a) {
        var b = a instanceof AST_Var ? a.definitions[0].name : null,
            c = Y(!0);
        return l(")"), new AST_ForIn({
            init: a,
            name: b,
            object: c,
            body: Z(r)
        })
    }

    function z() {
        var a = o(),
            b = r(),
            c = null;
        return d("keyword", "else") && (f(), c = r()), new AST_If({
            condition: a,
            body: b,
            alternative: c
        })
    }

    function A() {
        l("{");
        for (var a = []; !d("punc", "}");) d("eof") && j(), a.push(r());
        return f(), a
    }

    function B() {
        l("{");
        for (var h, a = [], b = null, e = null; !d("punc", "}");) d("eof") && j(), d("keyword", "case") ? (e && (e.end = g()), b = [], e = new AST_Case({
            start: (h = c.token, f(), h),
            expression: Y(!0),
            body: b
        }), a.push(e), l(":")) : d("keyword", "default") ? (e && (e.end = g()), b = [], e = new AST_Default({
            start: (h = c.token, f(), l(":"), h),
            body: b
        }), a.push(e)) : (b || j(), b.push(r()));
        return e && (e.end = g()), f(), a
    }

    function C() {
        var i, j, a = A(),
            b = null,
            e = null;
        return d("keyword", "catch") && (i = c.token, f(), l("("), j = P(AST_SymbolCatch), l(")"), b = new AST_Catch({
            start: i,
            argname: j,
            body: A(),
            end: g()
        })), d("keyword", "finally") && (i = c.token, f(), e = new AST_Finally({
            start: i,
            body: A(),
            end: g()
        })), b || e || h("缺少 catch/finally 块"), new AST_Try({
            body: a,
            bcatch: b,
            bfinally: e
        })
    }

    function D(a, b) {
        for (var e = []; e.push(new AST_VarDef({
            start: c.token,
            name: P(b ? AST_SymbolConst : AST_SymbolVar),
            value: d("operator", "=") ? (f(), Y(!1, a)) : null,
            end: g()
        })), d("punc", ",");) f();
        return e
    }

    function H() {
        var b, a = c.token;
        switch (a.type) {
            case "name":
            case "keyword":
                b = O(AST_SymbolRef);
                break;
            case "num":
                b = new AST_Number({
                    start: a,
                    end: a,
                    value: a.value
                });
                break;
            case "string":
                b = new AST_String({
                    start: a,
                    end: a,
                    value: a.value
                });
                break;
            case "regexp":
                b = new AST_RegExp({
                    start: a,
                    end: a,
                    value: a.value
                });
                break;
            case "atom":
                switch (a.value) {
                    case "false":
                        b = new AST_False({
                            start: a,
                            end: a
                        });
                        break;
                    case "true":
                        b = new AST_True({
                            start: a,
                            end: a
                        });
                        break;
                    case "null":
                        b = new AST_Null({
                            start: a,
                            end: a
                        })
                }
        }
        return f(), b
    }

    function J(a, b, e) {
        for (var g = !0, h = []; !d("punc", a) && (g ? g = !1 : l(","), !b || !d("punc", a));) d("punc", ",") && e ? h.push(new AST_Hole({
            start: c.token,
            end: c.token
        })) : h.push(Y(!1));
        return f(), h
    }

    function M() {
        var a = c.token;
        switch (f(), a.type) {
            case "num":
            case "string":
            case "name":
            case "operator":
            case "keyword":
            case "atom":
                return a.value;
            default:
                j()
        }
    }

    function N() {
        var a = c.token;
        switch (f(), a.type) {
            case "name":
            case "operator":
            case "keyword":
            case "atom":
                return a.value;
            default:
                j()
        }
    }

    function O(a) {
        var b = c.token.value;
        return new ("this" == b ? AST_This : a)({
            name: String(b),
            start: c.token,
            end: c.token
        })
    }

    function P(a, b) {
        if (!d("name")) return b || h("Name expected"), null;
        var c = O(a);
        return f(), c
    }

    function S(a, b, c) {
        return "++" != b && "--" != b || W(c) || h(b + " 运算符的使用无效"), new a({
            operator: b,
            expression: c
        })
    }

    function U(a) {
        return T(R(!0), 0, a)
    }

    function W(a) {
        return b.strict ? a instanceof AST_This ? !1 : a instanceof AST_PropAccess || a instanceof AST_Symbol : !0
    }

    function Z(a) {
        ++c.in_loop;
        var b = a();
        return --c.in_loop, b
    }
    var c, r, y, E, F, G, I, K, L, Q, R, T, V, X, Y;
    return b = defaults(b, {
        strict: !1,
        filename: null,
        toplevel: null,
        expression: !1,
        html5_comments: !0
    }), c = {
        input: "string" == typeof a ? tokenizer(a, b.filename, b.html5_comments) : a,
        token: null,
        prev: null,
        peeked: null,
        in_function: 0,
        in_directives: !0,
        in_loop: 0,
        labels: []
    }, c.token = f(), r = p(function () {
        var a, b, i;
        switch (q(), c.token.type) {
            case "string":
                return b = c.in_directives, i = t(), b && i.body instanceof AST_String && !d("punc", ",") ? new AST_Directive({
                    value: i.body.value
                }) : i;
            case "num":
            case "regexp":
            case "operator":
            case "atom":
                return t();
            case "name":
                return is_token(e(), "punc", ":") ? s() : t();
            case "punc":
                switch (c.token.value) {
                    case "{":
                        return new AST_BlockStatement({
                            start: c.token,
                            body: A(),
                            end: g()
                        });
                    case "[":
                    case "(":
                        return t();
                    case ";":
                        return f(), new AST_EmptyStatement;
                    default:
                        j()
                }
            case "keyword":
                switch (a = c.token.value, f(), a) {
                    case "break":
                        return u(AST_Break);
                    case "continue":
                        return u(AST_Continue);
                    case "debugger":
                        return n(), new AST_Debugger;
                    case "do":
                        return new AST_Do({
                            body: Z(r),
                            condition: (k("keyword", "while"), a = o(), n(), a)
                        });
                    case "while":
                        return new AST_While({
                            condition: o(),
                            body: Z(r)
                        });
                    case "for":
                        return v();
                    case "function":
                        return y(AST_Defun);
                    case "if":
                        return z();
                    case "return":
                        return 0 == c.in_function && h("'return' 在函数之外"), new AST_Return({
                            value: d("punc", ";") ? (f(), null) : m() ? null : (a = Y(!0), n(), a)
                        });
                    case "switch":
                        return new AST_Switch({
                            expression: o(),
                            body: Z(B)
                        });
                    case "throw":
                        return c.token.nlb && h("'throw' 后出现非法换行符"), new AST_Throw({
                            value: (a = Y(!0), n(), a)
                        });
                    case "try":
                        return C();
                    case "var":
                        return a = E(), n(), a;
                    case "const":
                        return a = F(), n(), a;
                    case "with":
                        return new AST_With({
                            expression: o(),
                            body: r()
                        });
                    default:
                        j()
                }
        }
    }), y = function (a) {
        var b = a === AST_Defun,
            e = d("name") ? P(b ? AST_SymbolDefun : AST_SymbolLambda) : null;
        return b && !e && j(), l("("), new a({
            name: e,
            argnames: function (a, b) {
                for (; !d("punc", ")");) a ? a = !1 : l(","), b.push(P(AST_SymbolFunarg));
                return f(), b
            }(!0, []),
            body: function (a, b) {
                ++c.in_function, c.in_directives = !0, c.in_loop = 0, c.labels = [];
                var d = A();
                return --c.in_function, c.in_loop = a, c.labels = b, d
            }(c.in_loop, c.labels)
        })
    }, E = function (a) {
        return new AST_Var({
            start: g(),
            definitions: D(a, !1),
            end: g()
        })
    }, F = function () {
        return new AST_Const({
            start: g(),
            definitions: D(!1, !0),
            end: g()
        })
    }, G = function () {
        var e, b, a = c.token;
        return k("operator", "new"), b = I(!1), d("punc", "(") ? (f(), e = J(")")) : e = [], Q(new AST_New({
            start: a,
            expression: b,
            args: e,
            end: g()
        }), !0)
    }, I = function (a) {
        var b, e, h;
        if (d("operator", "new")) return G();
        if (b = c.token, d("punc")) {
            switch (b.value) {
                case "(":
                    return f(), e = Y(!0), e.start = b, e.end = c.token, l(")"), Q(e, a);
                case "[":
                    return Q(K(), a);
                case "{":
                    return Q(L(), a)
            }
            j()
        }
        return d("keyword", "function") ? (f(), h = y(AST_Function), h.start = b, h.end = g(), Q(h, a)) : ATOMIC_START_TOKEN[c.token.type] ? Q(H(), a) : (j(), void 0)
    }, K = p(function () {
        return l("["), new AST_Array({
            elements: J("]", !b.strict, !0)
        })
    }), L = p(function () {
        var a, e, h, i, j;
        for (l("{"), a = !0, e = []; !d("punc", "}") && (a ? a = !1 : l(","), b.strict || !d("punc", "}"));) {
            if (h = c.token, i = h.type, j = M(), "name" == i && !d("punc", ":")) {
                if ("get" == j) {
                    e.push(new AST_ObjectGetter({
                        start: h,
                        key: H(),
                        value: y(AST_Accessor),
                        end: g()
                    }));
                    continue
                }
                if ("set" == j) {
                    e.push(new AST_ObjectSetter({
                        start: h,
                        key: H(),
                        value: y(AST_Accessor),
                        end: g()
                    }));
                    continue
                }
            }
            l(":"), e.push(new AST_ObjectKeyVal({
                start: h,
                key: j,
                value: Y(!1),
                end: g()
            }))
        }
        return f(), new AST_Object({
            properties: e
        })
    }), Q = function (a, b) {
        var e, c = a.start;
        return d("punc", ".") ? (f(), Q(new AST_Dot({
            start: c,
            expression: a,
            property: N(),
            end: g()
        }), b)) : d("punc", "[") ? (f(), e = Y(!0), l("]"), Q(new AST_Sub({
            start: c,
            expression: a,
            property: e,
            end: g()
        }), b)) : b && d("punc", "(") ? (f(), Q(new AST_Call({
            start: c,
            expression: a,
            args: J(")"),
            end: g()
        }), !0)) : a
    }, R = function (a) {
        var e, h, b = c.token;
        if (d("operator") && UNARY_PREFIX(b.value)) return f(), q(), e = S(AST_UnaryPrefix, b.value, R(a)), e.start = b, e.end = g(), e;
        for (h = I(a); d("operator") && UNARY_POSTFIX(c.token.value) && !c.token.nlb;) h = S(AST_UnaryPostfix, c.token.value, h), h.start = b, h.end = c.token, f();
        return h
    }, T = function (a, b, e) {
        var h, i, g = d("operator") ? c.token.value : null;
        return "in" == g && e && (g = null), h = null != g ? PRECEDENCE[g] : null, null != h && h > b ? (f(), i = T(R(!0), h, e), T(new AST_Binary({
            start: a.start,
            left: a,
            operator: g,
            right: i,
            end: i.end
        }), b, e)) : a
    }, V = function (a) {
        var h, b = c.token,
            e = U(a);
        return d("operator", "?") ? (f(), h = Y(!1), l(":"), new AST_Conditional({
            start: b,
            condition: e,
            consequent: h,
            alternative: Y(!1, a),
            end: g()
        })) : e
    }, X = function (a) {
        var b = c.token,
            e = V(a),
            i = c.token.value;
        if (d("operator") && ASSIGNMENT(i)) {
            if (W(e)) return f(), new AST_Assign({
                start: b,
                left: e,
                operator: i,
                right: X(a),
                end: g()
            });
            h("无效分配")
        }
        return e
    }, Y = function (a, b) {
        var g = c.token,
            h = X(b);
        return a && d("punc", ",") ? (f(), new AST_Seq({
            start: g,
            car: h,
            cdr: Y(!0, b),
            end: e()
        })) : h
    }, b.expression ? Y(!0) : function () {
        for (var f, h, a = c.token, e = []; !d("eof");) e.push(r());
        return f = g(), h = b.toplevel, h ? (h.body = h.body.concat(e), h.end = f) : h = new AST_Toplevel({
            start: a,
            body: e,
            end: f
        }), h
    }()
}

function SymbolDef(a, b, c) {
    this.name = c.name, this.orig = [c], this.scope = a, this.references = [], this.global = !1, this.mangled_name = null, this.undeclared = !1, this.constant = !1, this.index = b
}

function array_to_hash(a) {
    var c, b = Object.create(null);
    for (c = 0; c < a.length; ++c) b[a[c]] = !0;
    return b
}

function slice(a, b) {
    return Array.prototype.slice.call(a, b || 0)
}

function characters(a) {
    return a.split("")
}

function member(a, b) {
    for (var c = b.length; --c >= 0;)
        if (b[c] == a) return !0;
    return !1
}

function find_if(a, b) {
    for (var c = 0, d = b.length; d > c; ++c)
        if (a(b[c])) return b[c]
}

function repeat_string(a, b) {
    if (0 >= b) return "";
    if (1 == b) return a;
    var c = repeat_string(a, b >> 1);
    return c += c, 1 & b && (c += a), c
}

function DefaultsError(a, b) {
    Error.call(this, a), this.msg = a, this.defs = b
}

function defaults(a, b, c) {
    var d, e;
    if (a === !0 && (a = {}), d = a || {}, c)
        for (e in d) d.hasOwnProperty(e) && !b.hasOwnProperty(e) && DefaultsError.croak("`" + e + "` 不是受支持的选项", b);
    for (e in b) b.hasOwnProperty(e) && (d[e] = a && a.hasOwnProperty(e) ? a[e] : b[e]);
    return d
}

function merge(a, b) {
    for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
    return a
}

function noop() { }

function push_uniq(a, b) {
    a.indexOf(b) < 0 && a.push(b)
}

function string_template(a, b) {
    return a.replace(/\{(.+?)\}/g, function (a, c) {
        return b[c]
    })
}

function remove(a, b) {
    for (var c = a.length; --c >= 0;) a[c] === b && a.splice(c, 1)
}

function mergeSort(a, b) {
    function c(a, c) {
        for (var d = [], e = 0, f = 0, g = 0; e < a.length && f < c.length;) d[g++] = b(a[e], c[f]) <= 0 ? a[e++] : c[f++];
        return e < a.length && d.push.apply(d, a.slice(e)), f < c.length && d.push.apply(d, c.slice(f)), d
    }

    function d(a) {
        if (a.length <= 1) return a;
        var b = Math.floor(a.length / 2),
            e = a.slice(0, b),
            f = a.slice(b);
        return e = d(e), f = d(f), c(e, f)
    }
    return a.length < 2 ? a.slice() : d(a)
}

function set_difference(a, b) {
    return a.filter(function (a) {
        return b.indexOf(a) < 0
    })
}

function set_intersection(a, b) {
    return a.filter(function (a) {
        return b.indexOf(a) >= 0
    })
}

function makePredicate(a) {
    function f(a) {
        if (1 == a.length) return b += "return str === " + JSON.stringify(a[0]) + ";";
        b += "switch(str){";
        for (var c = 0; c < a.length; ++c) b += "case " + JSON.stringify(a[c]) + ":";
        b += "return true}return false;"
    }
    var b, c, d, e, g;
    a instanceof Array || (a = a.split(" ")), b = "", c = [];
    a: for (d = 0; d < a.length; ++d) {
        for (e = 0; e < c.length; ++e)
            if (c[e][0].length == a[d].length) {
                c[e].push(a[d]);
                continue a
            } c.push([a[d]])
    }
    if (c.length > 3) {
        for (c.sort(function (a, b) {
            return b.length - a.length
        }), b += "switch(str.length){", d = 0; d < c.length; ++d) g = c[d], b += "case " + g[0].length + ":", f(g);
        b += "}"
    } else f(a);
    return new Function("str", b)
}

function all(a, b) {
    for (var c = a.length; --c >= 0;)
        if (!b(a[c])) return !1;
    return !0
}

function Dictionary() {
    this._values = Object.create(null), this._size = 0
}
var AST_Statement, AST_Debugger, AST_Directive, AST_SimpleStatement, AST_Block, AST_BlockStatement, AST_EmptyStatement, AST_StatementWithBody, AST_LabeledStatement, AST_IterationStatement, AST_DWLoop, AST_Do, AST_While, AST_For, AST_ForIn, AST_With, AST_Scope, AST_Toplevel, AST_Lambda, AST_Accessor, AST_Function, AST_Defun, AST_Jump, AST_Exit, AST_Return, AST_Throw, AST_LoopControl, AST_Break, AST_Continue, AST_If, AST_Switch, AST_SwitchBranch, AST_Default, AST_Case, AST_Try, AST_Catch, AST_Finally, AST_Definitions, AST_Var, AST_Const, AST_VarDef, AST_Call, AST_New, AST_Seq, AST_PropAccess, AST_Dot, AST_Sub, AST_Unary, AST_UnaryPrefix, AST_UnaryPostfix, AST_Binary, AST_Conditional, AST_Assign, AST_Array, AST_Object, AST_ObjectProperty, AST_ObjectKeyVal, AST_ObjectSetter, AST_ObjectGetter, AST_Symbol, AST_SymbolAccessor, AST_SymbolDeclaration, AST_SymbolVar, AST_SymbolConst, AST_SymbolFunarg, AST_SymbolDefun, AST_SymbolLambda, AST_SymbolCatch, AST_Label, AST_SymbolRef, AST_LabelRef, AST_This, AST_Constant, AST_String, AST_Number, AST_RegExp, AST_Atom, AST_Null, AST_NaN, AST_Undefined, AST_Hole, AST_Infinity, AST_Boolean, AST_False, AST_True, KEYWORDS, KEYWORDS_ATOM, RESERVED_WORDS, KEYWORDS_BEFORE_EXPRESSION, OPERATOR_CHARS, RE_HEX_NUMBER, RE_OCT_NUMBER, RE_DEC_NUMBER, OPERATORS, WHITESPACE_CHARS, PUNC_BEFORE_EXPRESSION, PUNC_CHARS, REGEXP_MODIFIERS, UNICODE, EX_EOF, UNARY_PREFIX, UNARY_POSTFIX, ASSIGNMENT, PRECEDENCE, STATEMENTS_WITH_LABELS, ATOMIC_START_TOKEN, base54, MAP, AST_Token = DEFNODE("Token", "type value line col pos endpos nlb comments_before file", {}, null),
    AST_Node = DEFNODE("Node", "start end", {
        clone: function () {
            return new this.CTOR(this)
        },
        $documentation: "所有 AST 节点的基类",
        $propdoc: {
            start: "[AST_Token] 该节点的第一个token",
            end: "[AST_Token] 该节点的最后一个token"
        },
        _walk: function (a) {
            return a._visit(this)
        },
        walk: function (a) {
            return this._walk(a)
        }
    }, null);
AST_Node.warn_function = null, AST_Node.warn = function (a, b) {
    AST_Node.warn_function && AST_Node.warn_function(string_template(a, b))
}, AST_Statement = DEFNODE("Statement", null, {
    $documentation: "所有语句的基类"
}), AST_Debugger = DEFNODE("Debugger", null, {
    $documentation: "代表调试器语句"
}, AST_Statement), AST_Directive = DEFNODE("Directive", "value scope", {
    $documentation: '代表一个指令，如 "use strict"；',
    $propdoc: {
        value: "[string] 该指令的值作为纯字符串（它不是 AST_String！）",
        scope: "[AST_Scope/S] 该指令影响的范围"
    }
}, AST_Statement), AST_SimpleStatement = DEFNODE("SimpleStatement", "body", {
    $documentation: "由表达式组成的语句，即 a = 1 + 2",
    $propdoc: {
        body: "[AST_Node] 表达式节点（不应是 AST_Statement 的实例）"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.body._walk(a)
        })
    }
}, AST_Statement), AST_Block = DEFNODE("Block", "body", {
    $documentation: "陈述正文（通常放在括号内）",
    $propdoc: {
        body: "[AST_Statement*] 语句数组"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            walk_body(this, a)
        })
    }
}, AST_Statement), AST_BlockStatement = DEFNODE("BlockStatement", null, {
    $documentation: "块语句"
}, AST_Block), AST_EmptyStatement = DEFNODE("EmptyStatement", null, {
    $documentation: "空语句（空块或简单的分号）",
    _walk: function (a) {
        return a._visit(this)
    }
}, AST_Statement), AST_StatementWithBody = DEFNODE("StatementWithBody", "body", {
    $documentation: "包含一个嵌套主体的所有语句的基类：`For`、`ForIn`、`Do`、`While`、`With`",
    $propdoc: {
        body: "[AST_Statement] 主体；即使它是 AST_EmptyStatement，它也应该始终存在"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.body._walk(a)
        })
    }
}, AST_Statement), AST_LabeledStatement = DEFNODE("LabeledStatement", "label", {
    $documentation: "带标签的声明",
    $propdoc: {
        label: "[AST_Label] 标签定义"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.label._walk(a), this.body._walk(a)
        })
    }
}, AST_StatementWithBody), AST_IterationStatement = DEFNODE("IterationStatement", null, {
    $documentation: "内部类。所有循环都继承自它。"
}, AST_StatementWithBody), AST_DWLoop = DEFNODE("DWLoop", "condition", {
    $documentation: "do/while 语句的类型",
    $propdoc: {
        condition: "[AST_Node] 循环条件。不应该是 AST_Statement 的实例"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.condition._walk(a), this.body._walk(a)
        })
    }
}, AST_IterationStatement), AST_Do = DEFNODE("Do", null, {
    $documentation: "一个 `do` 语句"
}, AST_DWLoop), AST_While = DEFNODE("While", null, {
    $documentation: "一个 `while` 语句"
}, AST_DWLoop), AST_For = DEFNODE("For", "init condition step", {
    $documentation: "一个'for'语句",
    $propdoc: {
        init: "[AST_Node?] `for` 初始化代码，如果为空则为 null",
        condition: "[AST_Node?] `for` 终止子句，如果为空则为 null",
        step: "[AST_Node?] `for` 更新子句，如果为空则为 null"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.init && this.init._walk(a), this.condition && this.condition._walk(a), this.step && this.step._walk(a), this.body._walk(a)
        })
    }
}, AST_IterationStatement), AST_ForIn = DEFNODE("ForIn", "init name object", {
    $documentation: "一个'for ... in'语句",
    $propdoc: {
        init: "[AST_Node] `for/in` 初始化代码",
        name: "[AST_SymbolRef?] 循环变量，仅当 `init` 为 AST_Var 时",
        object: "[AST_Node] 我们正在循环的对象"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.init._walk(a), this.object._walk(a), this.body._walk(a)
        })
    }
}, AST_IterationStatement), AST_With = DEFNODE("With", "expression", {
    $documentation: "一个 `with` 语句",
    $propdoc: {
        expression: "[AST_Node] `with` 表达式"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.expression._walk(a), this.body._walk(a)
        })
    }
}, AST_StatementWithBody), AST_Scope = DEFNODE("Scope", "directives variables functions uses_with uses_eval parent_scope enclosed cname", {
    $documentation: "引入词法作用域的所有语句的基类",
    $propdoc: {
        directives: "[string*/S] 在此范围内声明的指令数组",
        variables: "[Object/S] 在此范围内定义的所有变量/函数的名称映射 -> SymbolDef",
        functions: "[Object/S] 类似'变量'，但仅列出函数声明",
        uses_with: "[boolean/S] 告诉这个作用域是否使用 `with` 语句",
        uses_eval: "[boolean/S] 告诉此范围是否包含对全局'eval'的直接调用",
        parent_scope: "[AST_Scope?/S] 链接到父范围",
        enclosed: "[SymbolDef*/S] 从此范围或任何子范围访问的所有符号定义的列表",
        cname: "[integer/S] 修饰变量的当前索引（由修饰器内部使用）"
    }
}, AST_Block), AST_Toplevel = DEFNODE("Toplevel", "globals", {
    $documentation: "顶级范围",
    $propdoc: {
        globals: "[Object/S] 名称映射 -> 所有未声明名称的 SymbolDef"
    },
    wrap_enclose: function (a) {
        var e, b = this,
            c = [],
            d = [];
        return a.forEach(function (a) {
            var b = a.lastIndexOf(":");
            c.push(a.substr(0, b)), d.push(a.substr(b + 1))
        }), e = "(function(" + d.join(",") + "){ '$ORIG'; })(" + c.join(",") + ")", e = parse(e), e = e.transform(new TreeTransformer(function (a) {
            return a instanceof AST_Directive && "$ORIG" == a.value ? MAP.splice(b.body) : void 0
        }))
    },
    wrap_commonjs: function (a, b) {
        var e, c = this,
            d = [];
        return b && (c.figure_out_scope(), c.walk(new TreeWalker(function (a) {
            a instanceof AST_SymbolDeclaration && a.definition().global && (find_if(function (b) {
                return b.name == a.name
            }, d) || d.push(a))
        }))), e = "(function(exports, global){ global['" + a + "'] = exports; '$ORIG'; '$EXPORTS'; }({}, (function(){return this}())))", e = parse(e), e = e.transform(new TreeTransformer(function (a) {
            if (a instanceof AST_SimpleStatement && (a = a.body, a instanceof AST_String)) switch (a.getValue()) {
                case "$ORIG":
                    return MAP.splice(c.body);
                case "$EXPORTS":
                    var b = [];
                    return d.forEach(function (a) {
                        b.push(new AST_SimpleStatement({
                            body: new AST_Assign({
                                left: new AST_Sub({
                                    expression: new AST_SymbolRef({
                                        name: "exports"
                                    }),
                                    property: new AST_String({
                                        value: a.name
                                    })
                                }),
                                operator: "=",
                                right: new AST_SymbolRef(a)
                            })
                        }))
                    }), MAP.splice(b)
            }
        }))
    }
}, AST_Scope), AST_Lambda = DEFNODE("Lambda", "name argnames uses_arguments", {
    $documentation: "Base class for functions",
    $propdoc: {
        name: "[AST_SymbolDeclaration?] 该函数的名称",
        argnames: "[AST_SymbolFunarg*] 函数参数数组",
        uses_arguments: "[boolean/S] 告诉这个函数是否访问参数数组"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.name && this.name._walk(a), this.argnames.forEach(function (b) {
                b._walk(a)
            }), walk_body(this, a)
        })
    }
}, AST_Scope), AST_Accessor = DEFNODE("Accessor", null, {
    $documentation: "setter/getter 函数。 `name` 属性始终为空。"
}, AST_Lambda), AST_Function = DEFNODE("Function", null, {
    $documentation: "函数表达式"
}, AST_Lambda), AST_Defun = DEFNODE("Defun", null, {
    $documentation: "函数定义"
}, AST_Lambda), AST_Jump = DEFNODE("Jump", null, {
    $documentation: "'jumps'的基类（目前是`return`, `throw`, `break` 和 `continue`）"
}, AST_Statement), AST_Exit = DEFNODE("Exit", "value", {
    $documentation: "'exits'的基类（`return` 和 `throw`）",
    $propdoc: {
        value: "[AST_Node?] 该语句返回或抛出的值； AST_Return 可以为 null"
    },
    _walk: function (a) {
        return a._visit(this, this.value && function () {
            this.value._walk(a)
        })
    }
}, AST_Jump), AST_Return = DEFNODE("Return", null, {
    $documentation: "A `return` statement"
}, AST_Exit), AST_Throw = DEFNODE("Throw", null, {
    $documentation: "A `throw` statement"
}, AST_Exit), AST_LoopControl = DEFNODE("LoopControl", "label", {
    $documentation: "循环控制语句的基类（`break` 和 `continue`）",
    $propdoc: {
        label: "[AST_LabelRef?] the label, or null if none"
    },
    _walk: function (a) {
        return a._visit(this, this.label && function () {
            this.label._walk(a)
        })
    }
}, AST_Jump), AST_Break = DEFNODE("Break", null, {
    $documentation: "A `break` statement"
}, AST_LoopControl), AST_Continue = DEFNODE("Continue", null, {
    $documentation: "A `continue` statement"
}, AST_LoopControl), AST_If = DEFNODE("If", "condition alternative", {
    $documentation: "A `if` statement",
    $propdoc: {
        condition: "[AST_Node] the `if` condition",
        alternative: "[AST_Statement?] `else` 部分，如果不存在则为 null"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.condition._walk(a), this.body._walk(a), this.alternative && this.alternative._walk(a)
        })
    }
}, AST_StatementWithBody), AST_Switch = DEFNODE("Switch", "expression", {
    $documentation: "A `switch` statement",
    $propdoc: {
        expression: "[AST_Node] `switch` '判别式'"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.expression._walk(a), walk_body(this, a)
        })
    }
}, AST_Block), AST_SwitchBranch = DEFNODE("SwitchBranch", null, {
    $documentation: "Base class for `switch` branches"
}, AST_Block), AST_Default = DEFNODE("Default", null, {
    $documentation: "A `default` switch branch"
}, AST_SwitchBranch), AST_Case = DEFNODE("Case", "expression", {
    $documentation: "A `case` switch branch",
    $propdoc: {
        expression: "[AST_Node] the `case` expression"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.expression._walk(a), walk_body(this, a)
        })
    }
}, AST_SwitchBranch), AST_Try = DEFNODE("Try", "bcatch bfinally", {
    $documentation: "A `try` statement",
    $propdoc: {
        bcatch: "[AST_Catch?] the catch block, or null if not present",
        bfinally: "[AST_Finally?] the finally block, or null if not present"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            walk_body(this, a), this.bcatch && this.bcatch._walk(a), this.bfinally && this.bfinally._walk(a)
        })
    }
}, AST_Block), AST_Catch = DEFNODE("Catch", "argname", {
    $documentation: "一个 `catch` 节点；仅作为 `try` 语句的一部分才有意义",
    $propdoc: {
        argname: "[AST_SymbolCatch] symbol for the exception"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.argname._walk(a), walk_body(this, a)
        })
    }
}, AST_Block), AST_Finally = DEFNODE("Finally", null, {
    $documentation: "A `finally` node; only makes sense as part of a `try` statement"
}, AST_Block), AST_Definitions = DEFNODE("Definitions", "definitions", {
    $documentation: "`var` 或 `const` 节点的基类（变量声明/初始化）",
    $propdoc: {
        definitions: "[AST_VarDef*] array of variable definitions"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.definitions.forEach(function (b) {
                b._walk(a)
            })
        })
    }
}, AST_Statement), AST_Var = DEFNODE("Var", null, {
    $documentation: "A `var` statement"
}, AST_Definitions), AST_Const = DEFNODE("Const", null, {
    $documentation: "A `const` statement"
}, AST_Definitions), AST_VarDef = DEFNODE("VarDef", "name value", {
    $documentation: "A variable declaration; only appears in a AST_Definitions node",
    $propdoc: {
        name: "[AST_SymbolVar|AST_SymbolConst] name of the variable",
        value: "[AST_Node?] 初始化器，或者没有初始化器时为 null"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.name._walk(a), this.value && this.value._walk(a)
        })
    }
}), AST_Call = DEFNODE("Call", "expression args", {
    $documentation: "A function call expression",
    $propdoc: {
        expression: "[AST_Node] expression to invoke as function",
        args: "[AST_Node*] array of arguments"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.expression._walk(a), this.args.forEach(function (b) {
                b._walk(a)
            })
        })
    }
}), AST_New = DEFNODE("New", null, {
    $documentation: "对象实例化。派生自函数调用，因为它具有完全相同的属性"
}, AST_Call), AST_Seq = DEFNODE("Seq", "car cdr", {
    $documentation: "序列表达式（两个逗号分隔的表达式）",
    $propdoc: {
        car: "[AST_Node] 序列中的第一个元素",
        cdr: "[AST_Node] 序列中的第二个元素"
    },
    $cons: function (a, b) {
        var c = new AST_Seq(a);
        return c.car = a, c.cdr = b, c
    },
    $from_array: function (a) {
        var b, c, d;
        if (0 == a.length) return null;
        if (1 == a.length) return a[0].clone();
        for (b = null, c = a.length; --c >= 0;) b = AST_Seq.cons(a[c], b);
        for (d = b; d;) {
            if (d.cdr && !d.cdr.cdr) {
                d.cdr = d.cdr.car;
                break
            }
            d = d.cdr
        }
        return b
    },
    to_array: function () {
        for (var a = this, b = []; a;) {
            if (b.push(a.car), a.cdr && !(a.cdr instanceof AST_Seq)) {
                b.push(a.cdr);
                break
            }
            a = a.cdr
        }
        return b
    },
    add: function (a) {
        for (var c, b = this; b;) {
            if (!(b.cdr instanceof AST_Seq)) return c = AST_Seq.cons(b.cdr, a), b.cdr = c;
            b = b.cdr
        }
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.car._walk(a), this.cdr && this.cdr._walk(a)
        })
    }
}), AST_PropAccess = DEFNODE("PropAccess", "expression property", {
    $documentation: '属性访问表达式的基类，即 `a.foo` 或 `a["foo"]`',
    $propdoc: {
        expression: "[AST_Node] `容器` 表达式",
        property: "[AST_Node|string] 要访问的属性。对于 AST_Dot，这始终是一个纯字符串，而对于 AST_Sub，它是任意 AST_Node"
    }
}), AST_Dot = DEFNODE("Dot", null, {
    $documentation: "点式属性访问表达式",
    _walk: function (a) {
        return a._visit(this, function () {
            this.expression._walk(a)
        })
    }
}, AST_PropAccess), AST_Sub = DEFNODE("Sub", null, {
    $documentation: '索引式属性访问，即 `a["foo"]`',
    _walk: function (a) {
        return a._visit(this, function () {
            this.expression._walk(a), this.property._walk(a)
        })
    }
}, AST_PropAccess), AST_Unary = DEFNODE("Unary", "operator expression", {
    $documentation: "Base class for unary expressions",
    $propdoc: {
        operator: "[string] the operator",
        expression: "[AST_Node] 此一元运算符适用的表达式"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.expression._walk(a)
        })
    }
}), AST_UnaryPrefix = DEFNODE("UnaryPrefix", null, {
    $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`"
}, AST_Unary), AST_UnaryPostfix = DEFNODE("UnaryPostfix", null, {
    $documentation: "Unary postfix expression, i.e. `i++`"
}, AST_Unary), AST_Binary = DEFNODE("Binary", "left operator right", {
    $documentation: "Binary expression, i.e. `a + b`",
    $propdoc: {
        left: "[AST_Node] left-hand side expression",
        operator: "[string] the operator",
        right: "[AST_Node] right-hand side expression"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.left._walk(a), this.right._walk(a)
        })
    }
}), AST_Conditional = DEFNODE("Conditional", "condition consequent alternative", {
    $documentation: "使用三元运算符的条件表达式，即 `a ? b ：c`",
    $propdoc: {
        condition: "[AST_Node]",
        consequent: "[AST_Node]",
        alternative: "[AST_Node]"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.condition._walk(a), this.consequent._walk(a), this.alternative._walk(a)
        })
    }
}), AST_Assign = DEFNODE("Assign", null, {
    $documentation: "赋值表达式 — `a = b + 5`"
}, AST_Binary), AST_Array = DEFNODE("Array", "elements", {
    $documentation: "An array literal",
    $propdoc: {
        elements: "[AST_Node*] array of elements"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.elements.forEach(function (b) {
                b._walk(a)
            })
        })
    }
}), AST_Object = DEFNODE("Object", "properties", {
    $documentation: "An object literal",
    $propdoc: {
        properties: "[AST_ObjectProperty*] 属性数组"
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.properties.forEach(function (b) {
                b._walk(a)
            })
        })
    }
}), AST_ObjectProperty = DEFNODE("ObjectProperty", "key value", {
    $documentation: "文字对象属性的基类",
    $propdoc: {
        key: "[string] 转换为 ObjectKeyVal 字符串的属性名称。对于 setter 和 getter 来说，这是一个任意的 AST_Node。",
        value: "[AST_Node] property value.  For setters and getters this is an AST_Function."
    },
    _walk: function (a) {
        return a._visit(this, function () {
            this.value._walk(a)
        })
    }
}), AST_ObjectKeyVal = DEFNODE("ObjectKeyVal", null, {
    $documentation: "A key: value object property"
}, AST_ObjectProperty), AST_ObjectSetter = DEFNODE("ObjectSetter", null, {
    $documentation: "An object setter property"
}, AST_ObjectProperty), AST_ObjectGetter = DEFNODE("ObjectGetter", null, {
    $documentation: "An object getter property"
}, AST_ObjectProperty), AST_Symbol = DEFNODE("Symbol", "scope name thedef", {
    $propdoc: {
        name: "[string] name of this symbol",
        scope: "[AST_Scope/S] the current scope (not necessarily the definition scope)",
        thedef: "[SymbolDef/S] the definition of this symbol"
    },
    $documentation: "Base class for all symbols"
}), AST_SymbolAccessor = DEFNODE("SymbolAccessor", null, {
    $documentation: "The name of a property accessor (setter/getter function)"
}, AST_Symbol), AST_SymbolDeclaration = DEFNODE("SymbolDeclaration", "init", {
    $documentation: "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)",
    $propdoc: {
        init: "[AST_Node*/S] array of initializers for this declaration."
    }
}, AST_Symbol), AST_SymbolVar = DEFNODE("SymbolVar", null, {
    $documentation: "Symbol defining a variable"
}, AST_SymbolDeclaration), AST_SymbolConst = DEFNODE("SymbolConst", null, {
    $documentation: "A constant declaration"
}, AST_SymbolDeclaration), AST_SymbolFunarg = DEFNODE("SymbolFunarg", null, {
    $documentation: "Symbol naming a function argument"
}, AST_SymbolVar), AST_SymbolDefun = DEFNODE("SymbolDefun", null, {
    $documentation: "Symbol defining a function"
}, AST_SymbolDeclaration), AST_SymbolLambda = DEFNODE("SymbolLambda", null, {
    $documentation: "Symbol naming a function expression"
}, AST_SymbolDeclaration), AST_SymbolCatch = DEFNODE("SymbolCatch", null, {
    $documentation: "Symbol naming the exception in catch"
}, AST_SymbolDeclaration), AST_Label = DEFNODE("Label", "references", {
    $documentation: "Symbol naming a label (declaration)",
    $propdoc: {
        references: "[AST_LoopControl*] a list of nodes referring to this label"
    },
    initialize: function () {
        this.references = [], this.thedef = this
    }
}, AST_Symbol), AST_SymbolRef = DEFNODE("SymbolRef", null, {
    $documentation: "引用某些符号（不是定义/声明）"
}, AST_Symbol), AST_LabelRef = DEFNODE("LabelRef", null, {
    $documentation: "参考标签符号"
}, AST_Symbol), AST_This = DEFNODE("This", null, {
    $documentation: "The `this` symbol"
}, AST_Symbol), AST_Constant = DEFNODE("Constant", null, {
    $documentation: "所有常量的基类",
    getValue: function () {
        return this.value
    }
}), AST_String = DEFNODE("String", "value", {
    $documentation: "字符串",
    $propdoc: {
        value: "[string] 该字符串的内容"
    }
}, AST_Constant), AST_Number = DEFNODE("Number", "value", {
    $documentation: "数字字面量",
    $propdoc: {
        value: "[number] 数值"
    }
}, AST_Constant), AST_RegExp = DEFNODE("RegExp", "value", {
    $documentation: "正则表达式文字",
    $propdoc: {
        value: "[RegExp] 实际的正则表达式"
    }
}, AST_Constant), AST_Atom = DEFNODE("Atom", null, {
    $documentation: "Base class for atoms"
}, AST_Constant), AST_Null = DEFNODE("Null", null, {
    $documentation: "The `null` atom",
    value: null
}, AST_Atom), AST_NaN = DEFNODE("NaN", null, {
    $documentation: "不可能的值",
    value: 0 / 0
}, AST_Atom), AST_Undefined = DEFNODE("Undefined", null, {
    $documentation: " `undefined` 值",
    value: void 0
}, AST_Atom), AST_Hole = DEFNODE("Hole", null, {
    $documentation: "A hole in an array",
    value: void 0
}, AST_Atom), AST_Infinity = DEFNODE("Infinity", null, {
    $documentation: "The `Infinity` value",
    value: 1 / 0
}, AST_Atom), AST_Boolean = DEFNODE("Boolean", null, {
    $documentation: "布尔值的类型"
}, AST_Atom), AST_False = DEFNODE("False", null, {
    $documentation: "The `false` atom",
    value: !1
}, AST_Boolean), AST_True = DEFNODE("True", null, {
    $documentation: "The `true` atom",
    value: !0
}, AST_Boolean), TreeWalker.prototype = {
    _visit: function (a, b) {
        this.stack.push(a);
        var c = this.visit(a, b ? function () {
            b.call(a)
        } : noop);
        return !c && b && b.call(a), this.stack.pop(), c
    },
    parent: function (a) {
        return this.stack[this.stack.length - 2 - (a || 0)]
    },
    push: function (a) {
        this.stack.push(a)
    },
    pop: function () {
        return this.stack.pop()
    },
    self: function () {
        return this.stack[this.stack.length - 1]
    },
    find_parent: function (a) {
        var c, d, b = this.stack;
        for (c = b.length; --c >= 0;)
            if (d = b[c], d instanceof a) return d
    },
    has_directive: function (a) {
        return this.find_parent(AST_Scope).has_directive(a)
    },
    in_boolean_context: function () {
        for (var d, a = this.stack, b = a.length, c = a[--b]; b > 0;) {
            if (d = a[--b], d instanceof AST_If && d.condition === c || d instanceof AST_Conditional && d.condition === c || d instanceof AST_DWLoop && d.condition === c || d instanceof AST_For && d.condition === c || d instanceof AST_UnaryPrefix && "!" == d.operator && d.expression === c) return !0;
            if (!(d instanceof AST_Binary) || "&&" != d.operator && "||" != d.operator) return !1;
            c = d
        }
    },
    loopcontrol_target: function (a) {
        var c, d, b = this.stack;
        if (a) {
            for (c = b.length; --c >= 0;)
                if (d = b[c], d instanceof AST_LabeledStatement && d.label.name == a.name) return d.body
        } else
            for (c = b.length; --c >= 0;)
                if (d = b[c], d instanceof AST_Switch || d instanceof AST_IterationStatement) return d
    }
},
    function () {
        function a(a, b) {
            a.DEFMETHOD("_codegen", b)
        }

        function b(a, b) {
            a.DEFMETHOD("needs_parens", b)
        }

        function c(a) {
            var b = a.parent();
            return b instanceof AST_Unary ? !0 : b instanceof AST_Binary && !(b instanceof AST_Assign) ? !0 : b instanceof AST_Call && b.expression === this ? !0 : b instanceof AST_Conditional && b.condition === this ? !0 : b instanceof AST_PropAccess && b.expression === this ? !0 : void 0
        }

        function d(a, b, c) {
            var d = a.length - 1;
            a.forEach(function (a, e) {
                a instanceof AST_EmptyStatement || (c.indent(), a.print(c), e == d && b || (c.newline(), b && c.newline()))
            })
        }

        function e(a, b) {
            a.length > 0 ? b.with_block(function () {
                d(a, !1, b)
            }) : b.print("{}")
        }

        function f(a, b) {
            if (b.option("bracketize")) return n(a.body, b), void 0;
            if (!a.body) return b.force_semicolon();
            if (a.body instanceof AST_Do && !b.option("screw_ie8")) return n(a.body, b), void 0;
            for (var c = a.body; ;)
                if (c instanceof AST_If) {
                    if (!c.alternative) return n(a.body, b), void 0;
                    c = c.alternative
                } else {
                    if (!(c instanceof AST_StatementWithBody)) break;
                    c = c.body
                } i(a.body, b)
        }

        function g(a, b, c) {
            if (c) try {
                a.walk(new TreeWalker(function (a) {
                    if (a instanceof AST_Binary && "in" == a.operator) throw b
                })), a.print(b)
            } catch (d) {
                if (d !== b) throw d;
                a.print(b, !0)
            } else a.print(b)
        }

        function h(a) {
            return [92, 47, 46, 43, 42, 63, 40, 41, 91, 93, 123, 125, 36, 94, 58, 124, 33, 10, 13, 0, 65279, 8232, 8233].indexOf(a) < 0
        }

        function i(a, b) {
            b.option("bracketize") ? !a || a instanceof AST_EmptyStatement ? b.print("{}") : a instanceof AST_BlockStatement ? a.print(b) : b.with_block(function () {
                b.indent(), a.print(b), b.newline()
            }) : !a || a instanceof AST_EmptyStatement ? b.force_semicolon() : a.print(b)
        }

        function j(a) {
            for (var b = a.stack(), c = b.length, d = b[--c], e = b[--c]; c > 0;) {
                if (e instanceof AST_Statement && e.body === d) return !0;
                if (!(e instanceof AST_Seq && e.car === d || e instanceof AST_Call && e.expression === d && !(e instanceof AST_New) || e instanceof AST_Dot && e.expression === d || e instanceof AST_Sub && e.expression === d || e instanceof AST_Conditional && e.condition === d || e instanceof AST_Binary && e.left === d || e instanceof AST_UnaryPostfix && e.expression === d)) return !1;
                d = e, e = b[--c]
            }
        }

        function k(a, b) {
            return 0 == a.args.length && !b.option("beautify")
        }

        function l(a) {
            var d, b = a[0],
                c = b.length;
            for (d = 1; d < a.length; ++d) a[d].length < c && (b = a[d], c = b.length);
            return b
        }

        function m(a) {
            var d, b = a.toString(10),
                c = [b.replace(/^0\./, ".").replace("e+", "e")];
            return Math.floor(a) === a ? (a >= 0 ? c.push("0x" + a.toString(16).toLowerCase(), "0" + a.toString(8)) : c.push("-0x" + (-a).toString(16).toLowerCase(), "-0" + (-a).toString(8)), (d = /^(.*?)(0+)$/.exec(a)) && c.push(d[1] + "e" + d[2].length)) : (d = /^0?\.(0+)(.*)$/.exec(a)) && c.push(d[2] + "e-" + (d[1].length + d[2].length), b.substr(b.indexOf("."))), l(c)
        }

        function n(a, b) {
            return a instanceof AST_BlockStatement ? (a.print(b), void 0) : (b.with_block(function () {
                b.indent(), a.print(b), b.newline()
            }), void 0)
        }

        function o(a, b) {
            a.DEFMETHOD("add_source_map", function (a) {
                b(this, a)
            })
        }

        function p(a, b) {
            b.add_mapping(a.start)
        }
        AST_Node.DEFMETHOD("print", function (a, b) {
            function e() {
                c.add_comments(a), c.add_source_map(a), d(c, a)
            }
            var c = this,
                d = c._codegen;
            a.push_node(c), b || c.needs_parens(a) ? a.with_parens(e) : e(), a.pop_node()
        }), AST_Node.DEFMETHOD("print_to_string", function (a) {
            var b = OutputStream(a);
            return this.print(b), b.get()
        }), AST_Node.DEFMETHOD("add_comments", function (a) {
            var d, e, b = a.option("comments"),
                c = this;
            b && (d = c.start, d && !d._comments_dumped && (d._comments_dumped = !0, e = d.comments_before || [], c instanceof AST_Exit && c.value && c.value.walk(new TreeWalker(function (a) {
                return a.start && a.start.comments_before && (e = e.concat(a.start.comments_before), a.start.comments_before = []), a instanceof AST_Function || a instanceof AST_Array || a instanceof AST_Object ? !0 : void 0
            })), b.test ? e = e.filter(function (a) {
                return b.test(a.value)
            }) : "function" == typeof b && (e = e.filter(function (a) {
                return b(c, a)
            })), e.forEach(function (b) {
                /comment[134]/.test(b.type) ? (a.print("//" + b.value + "\n"), a.indent()) : "comment2" == b.type && (a.print("/*" + b.value + "*/"), d.nlb ? (a.print("\n"), a.indent()) : a.space())
            })))
        }), b(AST_Node, function () {
            return !1
        }), b(AST_Function, function (a) {
            return j(a)
        }), b(AST_Object, function (a) {
            return j(a)
        }), b(AST_Unary, function (a) {
            var b = a.parent();
            return b instanceof AST_PropAccess && b.expression === this
        }), b(AST_Seq, function (a) {
            var b = a.parent();
            return b instanceof AST_Call || b instanceof AST_Unary || b instanceof AST_Binary || b instanceof AST_VarDef || b instanceof AST_PropAccess || b instanceof AST_Array || b instanceof AST_ObjectProperty || b instanceof AST_Conditional
        }), b(AST_Binary, function (a) {
            var c, d, e, f, b = a.parent();
            return b instanceof AST_Call && b.expression === this ? !0 : b instanceof AST_Unary ? !0 : b instanceof AST_PropAccess && b.expression === this ? !0 : b instanceof AST_Binary && (c = b.operator, d = PRECEDENCE[c], e = this.operator, f = PRECEDENCE[e], d > f || d == f && this === b.right) ? !0 : void 0
        }), b(AST_PropAccess, function (a) {
            var b = a.parent();
            if (b instanceof AST_New && b.expression === this) try {
                this.walk(new TreeWalker(function (a) {
                    if (a instanceof AST_Call) throw b
                }))
            } catch (c) {
                if (c !== b) throw c;
                return !0
            }
        }), b(AST_Call, function (a) {
            var c, b = a.parent();
            return b instanceof AST_New && b.expression === this ? !0 : this.expression instanceof AST_Function && b instanceof AST_PropAccess && b.expression === this && (c = a.parent(1)) instanceof AST_Assign && c.left === b
        }), b(AST_New, function (a) {
            var b = a.parent();
            return k(this, a) && (b instanceof AST_PropAccess || b instanceof AST_Call && b.expression === this) ? !0 : void 0
        }), b(AST_Number, function (a) {
            var b = a.parent();
            return this.getValue() < 0 && b instanceof AST_PropAccess && b.expression === this ? !0 : void 0
        }), b(AST_NaN, function (a) {
            var b = a.parent();
            return b instanceof AST_PropAccess && b.expression === this ? !0 : void 0
        }), b(AST_Assign, c), b(AST_Conditional, c), a(AST_Directive, function (a, b) {
            b.print_string(a.value), b.semicolon()
        }), a(AST_Debugger, function (a, b) {
            b.print("debugger"), b.semicolon()
        }), AST_StatementWithBody.DEFMETHOD("_do_print_body", function (a) {
            i(this.body, a)
        }), a(AST_Statement, function (a, b) {
            a.body.print(b), b.semicolon()
        }), a(AST_Toplevel, function (a, b) {
            d(a.body, !0, b), b.print("")
        }), a(AST_LabeledStatement, function (a, b) {
            a.label.print(b), b.colon(), a.body.print(b)
        }), a(AST_SimpleStatement, function (a, b) {
            a.body.print(b), b.semicolon()
        }), a(AST_BlockStatement, function (a, b) {
            e(a.body, b)
        }), a(AST_EmptyStatement, function (a, b) {
            b.semicolon()
        }), a(AST_Do, function (a, b) {
            b.print("do"), b.space(), a._do_print_body(b), b.space(), b.print("while"), b.space(), b.with_parens(function () {
                a.condition.print(b)
            }), b.semicolon()
        }), a(AST_While, function (a, b) {
            b.print("while"), b.space(), b.with_parens(function () {
                a.condition.print(b)
            }), b.space(), a._do_print_body(b)
        }), a(AST_For, function (a, b) {
            b.print("for"), b.space(), b.with_parens(function () {
                !a.init || a.init instanceof AST_EmptyStatement ? b.print(";") : (a.init instanceof AST_Definitions ? a.init.print(b) : g(a.init, b, !0), b.print(";"), b.space()), a.condition ? (a.condition.print(b), b.print(";"), b.space()) : b.print(";"), a.step && a.step.print(b)
            }), b.space(), a._do_print_body(b)
        }), a(AST_ForIn, function (a, b) {
            b.print("for"), b.space(), b.with_parens(function () {
                a.init.print(b), b.space(), b.print("in"), b.space(), a.object.print(b)
            }), b.space(), a._do_print_body(b)
        }), a(AST_With, function (a, b) {
            b.print("with"), b.space(), b.with_parens(function () {
                a.expression.print(b)
            }), b.space(), a._do_print_body(b)
        }), AST_Lambda.DEFMETHOD("_do_print", function (a, b) {
            var c = this;
            b || a.print("function"), c.name && (a.space(), c.name.print(a)), a.with_parens(function () {
                c.argnames.forEach(function (b, c) {
                    c && a.comma(), b.print(a)
                })
            }), a.space(), e(c.body, a)
        }), a(AST_Lambda, function (a, b) {
            a._do_print(b)
        }), AST_Exit.DEFMETHOD("_do_print", function (a, b) {
            a.print(b), this.value && (a.space(), this.value.print(a)), a.semicolon()
        }), a(AST_Return, function (a, b) {
            a._do_print(b, "return")
        }), a(AST_Throw, function (a, b) {
            a._do_print(b, "throw")
        }), AST_LoopControl.DEFMETHOD("_do_print", function (a, b) {
            a.print(b), this.label && (a.space(), this.label.print(a)), a.semicolon()
        }), a(AST_Break, function (a, b) {
            a._do_print(b, "break")
        }), a(AST_Continue, function (a, b) {
            a._do_print(b, "continue")
        }), a(AST_If, function (a, b) {
            b.print("if"), b.space(), b.with_parens(function () {
                a.condition.print(b)
            }), b.space(), a.alternative ? (f(a, b), b.space(), b.print("else"), b.space(), i(a.alternative, b)) : a._do_print_body(b)
        }), a(AST_Switch, function (a, b) {
            b.print("switch"), b.space(), b.with_parens(function () {
                a.expression.print(b)
            }), b.space(), a.body.length > 0 ? b.with_block(function () {
                a.body.forEach(function (a, c) {
                    c && b.newline(), b.indent(!0), a.print(b)
                })
            }) : b.print("{}")
        }), AST_SwitchBranch.DEFMETHOD("_do_print_body", function (a) {
            this.body.length > 0 && (a.newline(), this.body.forEach(function (b) {
                a.indent(), b.print(a), a.newline()
            }))
        }), a(AST_Default, function (a, b) {
            b.print("default:"), a._do_print_body(b)
        }), a(AST_Case, function (a, b) {
            b.print("case"), b.space(), a.expression.print(b), b.print(":"), a._do_print_body(b)
        }), a(AST_Try, function (a, b) {
            b.print("try"), b.space(), e(a.body, b), a.bcatch && (b.space(), a.bcatch.print(b)), a.bfinally && (b.space(), a.bfinally.print(b))
        }), a(AST_Catch, function (a, b) {
            b.print("catch"), b.space(), b.with_parens(function () {
                a.argname.print(b)
            }), b.space(), e(a.body, b)
        }), a(AST_Finally, function (a, b) {
            b.print("finally"), b.space(), e(a.body, b)
        }), AST_Definitions.DEFMETHOD("_do_print", function (a, b) {
            var c, d, e;
            a.print(b), a.space(), this.definitions.forEach(function (b, c) {
                c && a.comma(), b.print(a)
            }), c = a.parent(), d = c instanceof AST_For || c instanceof AST_ForIn, e = d && c.init === this, e || a.semicolon()
        }), a(AST_Var, function (a, b) {
            a._do_print(b, "var")
        }), a(AST_Const, function (a, b) {
            a._do_print(b, "const")
        }), a(AST_VarDef, function (a, b) {
            var c, d;
            a.name.print(b), a.value && (b.space(), b.print("="), b.space(), c = b.parent(1), d = c instanceof AST_For || c instanceof AST_ForIn, g(a.value, b, d))
        }), a(AST_Call, function (a, b) {
            a.expression.print(b), a instanceof AST_New && k(a, b) || b.with_parens(function () {
                a.args.forEach(function (a, c) {
                    c && b.comma(), a.print(b)
                })
            })
        }), a(AST_New, function (a, b) {
            b.print("new"), b.space(), AST_Call.prototype._codegen(a, b)
        }), AST_Seq.DEFMETHOD("_do_print", function (a) {
            this.car.print(a), this.cdr && (a.comma(), a.should_break() && (a.newline(), a.indent()), this.cdr.print(a))
        }), a(AST_Seq, function (a, b) {
            a._do_print(b)
        }), a(AST_Dot, function (a, b) {
            var c = a.expression;
            c.print(b), c instanceof AST_Number && c.getValue() >= 0 && (/[xa-f.]/i.test(b.last()) || b.print(".")), b.print("."), b.add_mapping(a.end), b.print_name(a.property)
        }), a(AST_Sub, function (a, b) {
            a.expression.print(b), b.print("["), a.property.print(b), b.print("]")
        }), a(AST_UnaryPrefix, function (a, b) {
            var c = a.operator;
            b.print(c), (/^[a-z]/i.test(c) || /[+-]$/.test(c) && a.expression instanceof AST_UnaryPrefix && /^[+-]/.test(a.expression.operator)) && b.space(), a.expression.print(b)
        }), a(AST_UnaryPostfix, function (a, b) {
            a.expression.print(b), b.print(a.operator)
        }), a(AST_Binary, function (a, b) {
            a.left.print(b), b.space(), b.print(a.operator), "<" == a.operator && a.right instanceof AST_UnaryPrefix && "!" == a.right.operator && a.right.expression instanceof AST_UnaryPrefix && "--" == a.right.expression.operator ? b.print(" ") : b.space(), a.right.print(b)
        }), a(AST_Conditional, function (a, b) {
            a.condition.print(b), b.space(), b.print("?"), b.space(), a.consequent.print(b), b.space(), b.colon(), a.alternative.print(b)
        }), a(AST_Array, function (a, b) {
            b.with_square(function () {
                var c = a.elements,
                    d = c.length;
                d > 0 && b.space(), c.forEach(function (a, c) {
                    c && b.comma(), a.print(b), c === d - 1 && a instanceof AST_Hole && b.comma()
                }), d > 0 && b.space()
            })
        }), a(AST_Object, function (a, b) {
            a.properties.length > 0 ? b.with_block(function () {
                a.properties.forEach(function (a, c) {
                    c && (b.print(","), b.newline()), b.indent(), a.print(b)
                }), b.newline()
            }) : b.print("{}")
        }), a(AST_ObjectKeyVal, function (a, b) {
            var c = a.key;
            b.option("quote_keys") ? b.print_string(c + "") : ("number" == typeof c || !b.option("beautify") && +c + "" == c) && parseFloat(c) >= 0 ? b.print(m(c)) : (RESERVED_WORDS(c) ? b.option("screw_ie8") : is_identifier_string(c)) ? b.print_name(c) : b.print_string(c), b.colon(), a.value.print(b)
        }), a(AST_ObjectSetter, function (a, b) {
            b.print("set"), b.space(), a.key.print(b), a.value._do_print(b, !0)
        }), a(AST_ObjectGetter, function (a, b) {
            b.print("get"), b.space(), a.key.print(b), a.value._do_print(b, !0)
        }), a(AST_Symbol, function (a, b) {
            var c = a.definition();
            b.print_name(c ? c.mangled_name || c.name : a.name)
        }), a(AST_Undefined, function (a, b) {
            b.print("void 0")
        }), a(AST_Hole, noop), a(AST_Infinity, function (a, b) {
            b.print("1/0")
        }), a(AST_NaN, function (a, b) {
            b.print("0/0")
        }), a(AST_This, function (a, b) {
            b.print("this")
        }), a(AST_Constant, function (a, b) {
            b.print(a.getValue())
        }), a(AST_String, function (a, b) {
            b.print_string(a.getValue())
        }), a(AST_Number, function (a, b) {
            b.print(m(a.getValue()))
        }), a(AST_RegExp, function (a, b) {
            var d, c = a.getValue().toString();
            b.option("ascii_only") ? c = b.to_ascii(c) : b.option("unescape_regexps") && (c = c.split("\\\\").map(function (a) {
                return a.replace(/\\u[0-9a-fA-F]{4}|\\x[0-9a-fA-F]{2}/g, function (a) {
                    var b = parseInt(a.substr(2), 16);
                    return h(b) ? String.fromCharCode(b) : a
                })
            }).join("\\\\")), b.print(c), d = b.parent(), d instanceof AST_Binary && /^in/.test(d.operator) && d.left === a && b.print(" ")
        }), o(AST_Node, noop), o(AST_Directive, p), o(AST_Debugger, p), o(AST_Symbol, p), o(AST_Jump, p), o(AST_StatementWithBody, p), o(AST_LabeledStatement, noop), o(AST_Lambda, p), o(AST_Switch, p), o(AST_SwitchBranch, p), o(AST_BlockStatement, p), o(AST_Toplevel, noop), o(AST_New, p), o(AST_Try, p), o(AST_Catch, p), o(AST_Finally, p), o(AST_Definitions, p), o(AST_Constant, p), o(AST_ObjectProperty, function (a, b) {
            b.add_mapping(a.start, a.key)
        })
    }(), KEYWORDS = "break case catch const continue debugger default delete do else finally for function if in instanceof new return switch throw try typeof var void while with", KEYWORDS_ATOM = "false null true", RESERVED_WORDS = "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized this throws transient volatile yield " + KEYWORDS_ATOM + " " + KEYWORDS, KEYWORDS_BEFORE_EXPRESSION = "return new delete throw else case", KEYWORDS = makePredicate(KEYWORDS), RESERVED_WORDS = makePredicate(RESERVED_WORDS), KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION), KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM), OPERATOR_CHARS = makePredicate(characters("+-*&%=<>!?|~^")), RE_HEX_NUMBER = /^0x[0-9a-f]+$/i, RE_OCT_NUMBER = /^0[0-7]+$/, RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i, OPERATORS = makePredicate(["in", "instanceof", "typeof", "new", "void", "delete", "++", "--", "+", "-", "!", "~", "&", "|", "^", "*", "/", "%", ">>", "<<", ">>>", "<", ">", "<=", ">=", "==", "===", "!=", "!==", "?", "=", "+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=", "&&", "||"]), WHITESPACE_CHARS = makePredicate(characters("  \n\r \f​᠎             　")), PUNC_BEFORE_EXPRESSION = makePredicate(characters("[{(,.;:")), PUNC_CHARS = makePredicate(characters("[]{}(),;:")), REGEXP_MODIFIERS = makePredicate(characters("gmsiy")), UNICODE = {
        letter: new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0523\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971\\u0972\\u097B-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D3D\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8B\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10D0-\\u10FA\\u10FC\\u1100-\\u1159\\u115F-\\u11A2\\u11A8-\\u11F9\\u1200-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u1676\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19A9\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u2094\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2C6F\\u2C71-\\u2C7D\\u2C80-\\u2CE4\\u2D00-\\u2D25\\u2D30-\\u2D65\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31B7\\u31F0-\\u31FF\\u3400\\u4DB5\\u4E00\\u9FC3\\uA000-\\uA48C\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA65F\\uA662-\\uA66E\\uA67F-\\uA697\\uA717-\\uA71F\\uA722-\\uA788\\uA78B\\uA78C\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA90A-\\uA925\\uA930-\\uA946\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAC00\\uD7A3\\uF900-\\uFA2D\\uFA30-\\uFA6A\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),
        non_spacing_mark: new RegExp("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065E\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0900-\\u0902\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F90-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFD-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26]"),
        space_combining_mark: new RegExp("[\\u0903\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]"),
        connector_punctuation: new RegExp("[\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]")
    }, JS_Parse_Error.prototype.toString = function () {
        return this.message + " (line: " + this.line + ", col: " + this.col + ", pos: " + this.pos + ")" + "\n\n" + this.stack
    }, EX_EOF = {}, UNARY_PREFIX = makePredicate(["typeof", "void", "delete", "--", "++", "!", "~", "-", "+"]), UNARY_POSTFIX = makePredicate(["--", "++"]), ASSIGNMENT = makePredicate(["=", "+=", "-=", "/=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&="]), PRECEDENCE = function (a, b) {
        var c, d, e;
        for (c = 0; c < a.length; ++c)
            for (d = a[c], e = 0; e < d.length; ++e) b[d[e]] = c + 1;
        return b
    }([
        ["||"],
        ["&&"],
        ["|"],
        ["^"],
        ["&"],
        ["==", "===", "!=", "!=="],
        ["<", ">", "<=", ">=", "in", "instanceof"],
        [">>", "<<", ">>>"],
        ["+", "-"],
        ["*", "/", "%"]
    ], {}), STATEMENTS_WITH_LABELS = array_to_hash(["for", "do", "while", "switch"]), ATOMIC_START_TOKEN = array_to_hash(["atom", "num", "string", "regexp", "name"]), SymbolDef.prototype = {
        unmangleable: function (a) {
            return this.global && !(a && a.toplevel) || this.undeclared || !(a && a.eval) && (this.scope.uses_eval || this.scope.uses_with)
        },
        mangle: function (a) {
            if (!this.mangled_name && !this.unmangleable(a)) {
                var b = this.scope;
                !a.screw_ie8 && this.orig[0] instanceof AST_SymbolLambda && (b = b.parent_scope), this.mangled_name = b.next_mangled(a, this)
            }
        }
    }, AST_Toplevel.DEFMETHOD("figure_out_scope", function (a) {
        var b, c, d, e, f, g, h;
        a = defaults(a, {
            screw_ie8: !1
        }), b = this, c = b.parent_scope = null, d = null, e = 0, f = new TreeWalker(function (b, g) {
            var h, i, j, k;
            if (a.screw_ie8 && b instanceof AST_Catch) return h = c, c = new AST_Scope(b), c.init_scope_vars(e), c.parent_scope = h, g(), c = h, !0;
            if (b instanceof AST_Scope) return b.init_scope_vars(e), h = b.parent_scope = c, i = d, d = c = b, ++e, g(), --e, c = h, d = i, !0;
            if (b instanceof AST_Directive) return b.scope = c, push_uniq(c.directives, b.value), !0;
            if (b instanceof AST_With)
                for (j = c; j; j = j.parent_scope) j.uses_with = !0;
            else b instanceof AST_Symbol && (b.scope = c), b instanceof AST_SymbolLambda ? d.def_function(b) : b instanceof AST_SymbolDefun ? (b.scope = d.parent_scope).def_function(b) : b instanceof AST_SymbolVar || b instanceof AST_SymbolConst ? (k = d.def_variable(b), k.constant = b instanceof AST_SymbolConst, k.init = f.parent().value) : b instanceof AST_SymbolCatch && (a.screw_ie8 ? c : d).def_variable(b)
        }), b.walk(f), g = null, h = b.globals = new Dictionary, f = new TreeWalker(function (a, c) {
            var d, e, i, j, k;
            if (a instanceof AST_Lambda) return d = g, g = a, c(), g = d, !0;
            if (a instanceof AST_SymbolRef) {
                if (e = a.name, i = a.scope.find_variable(e)) a.thedef = i;
                else {
                    if (h.has(e) ? j = h.get(e) : (j = new SymbolDef(b, h.size(), a), j.undeclared = !0, j.global = !0, h.set(e, j)), a.thedef = j, "eval" == e && f.parent() instanceof AST_Call)
                        for (k = a.scope; k && !k.uses_eval; k = k.parent_scope) k.uses_eval = !0;
                    g && "arguments" == e && (g.uses_arguments = !0)
                }
                return a.reference(), !0
            }
        }), b.walk(f)
    }), AST_Scope.DEFMETHOD("init_scope_vars", function (a) {
        this.directives = [], this.variables = new Dictionary, this.functions = new Dictionary, this.uses_with = !1, this.uses_eval = !1, this.parent_scope = null, this.enclosed = [], this.cname = -1, this.nesting = a
    }), AST_Scope.DEFMETHOD("strict", function () {
        return this.has_directive("use strict")
    }), AST_Lambda.DEFMETHOD("init_scope_vars", function () {
        AST_Scope.prototype.init_scope_vars.apply(this, arguments), this.uses_arguments = !1
    }), AST_SymbolRef.DEFMETHOD("reference", function () {
        var b, a = this.definition();
        for (a.references.push(this), b = this.scope; b && (push_uniq(b.enclosed, a), b !== a.scope);) b = b.parent_scope;
        this.frame = this.scope.nesting - a.scope.nesting
    }), AST_Scope.DEFMETHOD("find_variable", function (a) {
        return a instanceof AST_Symbol && (a = a.name), this.variables.get(a) || this.parent_scope && this.parent_scope.find_variable(a)
    }), AST_Scope.DEFMETHOD("has_directive", function (a) {
        return this.parent_scope && this.parent_scope.has_directive(a) || (this.directives.indexOf(a) >= 0 ? this : null)
    }), AST_Scope.DEFMETHOD("def_function", function (a) {
        this.functions.set(a.name, this.def_variable(a))
    }), AST_Scope.DEFMETHOD("def_variable", function (a) {
        var b;
        return this.variables.has(a.name) ? (b = this.variables.get(a.name), b.orig.push(a)) : (b = new SymbolDef(this, this.variables.size(), a), this.variables.set(a.name, b), b.global = !this.parent_scope), a.thedef = b
    }), AST_Scope.DEFMETHOD("next_mangled", function (a) {
        var c, d, e, f, b = this.enclosed;
        a: for (; ;)
            if (c = base54(++this.cname), is_identifier(c) && !(a.except.indexOf(c) >= 0)) {
                for (d = b.length; --d >= 0;)
                    if (e = b[d], f = e.mangled_name || e.unmangleable(a) && e.name, c == f) continue a;
                return c
            }
    }), AST_Function.DEFMETHOD("next_mangled", function (a, b) {
        for (var d, c = b.orig[0] instanceof AST_SymbolFunarg && this.name && this.name.definition(); ;)
            if (d = AST_Lambda.prototype.next_mangled.call(this, a, b), !c || c.mangled_name != d) return d
    }), AST_Scope.DEFMETHOD("references", function (a) {
        return a instanceof AST_Symbol && (a = a.definition()), this.enclosed.indexOf(a) < 0 ? null : a
    }), AST_Symbol.DEFMETHOD("unmangleable", function (a) {
        return this.definition().unmangleable(a)
    }), AST_SymbolAccessor.DEFMETHOD("unmangleable", function () {
        return !0
    }), AST_Label.DEFMETHOD("unmangleable", function () {
        return !1
    }), AST_Symbol.DEFMETHOD("unreferenced", function () {
        return 0 == this.definition().references.length && !(this.scope.uses_eval || this.scope.uses_with)
    }), AST_Symbol.DEFMETHOD("undeclared", function () {
        return this.definition().undeclared
    }), AST_LabelRef.DEFMETHOD("undeclared", function () {
        return !1
    }), AST_Label.DEFMETHOD("undeclared", function () {
        return !1
    }), AST_Symbol.DEFMETHOD("definition", function () {
        return this.thedef
    }), AST_Symbol.DEFMETHOD("global", function () {
        return this.definition().global
    }), AST_Toplevel.DEFMETHOD("_default_mangler_options", function (a) {
        return defaults(a, {
            except: [],
            eval: !1,
            sort: !1,
            toplevel: !1,
            screw_ie8: !1
        })
    }), AST_Toplevel.DEFMETHOD("mangle_names", function (a) {
        var b, c, d;
        a = this._default_mangler_options(a), b = -1, c = [], d = new TreeWalker(function (e, f) {
            var g, i, j;
            if (e instanceof AST_LabeledStatement) return g = b, f(), b = g, !0;
            if (e instanceof AST_Scope) return d.parent(), i = [], e.variables.each(function (b) {
                a.except.indexOf(b.name) < 0 && i.push(b)
            }), a.sort && i.sort(function (a, b) {
                return b.references.length - a.references.length
            }), c.push.apply(c, i), void 0;
            if (e instanceof AST_Label) {
                do j = base54(++b); while (!is_identifier(j));
                return e.mangled_name = j, !0
            }
            return a.screw_ie8 && e instanceof AST_SymbolCatch ? (c.push(e.definition()), void 0) : void 0
        }), this.walk(d), c.forEach(function (b) {
            b.mangle(a)
        })
    }), AST_Toplevel.DEFMETHOD("compute_char_frequency", function (a) {
        a = this._default_mangler_options(a);
        var b = new TreeWalker(function (b) {
            b instanceof AST_Constant ? base54.consider(b.print_to_string()) : b instanceof AST_Return ? base54.consider("return") : b instanceof AST_Throw ? base54.consider("throw") : b instanceof AST_Continue ? base54.consider("continue") : b instanceof AST_Break ? base54.consider("break") : b instanceof AST_Debugger ? base54.consider("debugger") : b instanceof AST_Directive ? base54.consider(b.value) : b instanceof AST_While ? base54.consider("while") : b instanceof AST_Do ? base54.consider("do while") : b instanceof AST_If ? (base54.consider("if"), b.alternative && base54.consider("else")) : b instanceof AST_Var ? base54.consider("var") : b instanceof AST_Const ? base54.consider("const") : b instanceof AST_Lambda ? base54.consider("function") : b instanceof AST_For ? base54.consider("for") : b instanceof AST_ForIn ? base54.consider("for in") : b instanceof AST_Switch ? base54.consider("switch") : b instanceof AST_Case ? base54.consider("case") : b instanceof AST_Default ? base54.consider("default") : b instanceof AST_With ? base54.consider("with") : b instanceof AST_ObjectSetter ? base54.consider("set" + b.key) : b instanceof AST_ObjectGetter ? base54.consider("get" + b.key) : b instanceof AST_ObjectKeyVal ? base54.consider(b.key) : b instanceof AST_New ? base54.consider("new") : b instanceof AST_This ? base54.consider("this") : b instanceof AST_Try ? base54.consider("try") : b instanceof AST_Catch ? base54.consider("catch") : b instanceof AST_Finally ? base54.consider("finally") : b instanceof AST_Symbol && b.unmangleable(a) ? base54.consider(b.name) : b instanceof AST_Unary || b instanceof AST_Binary ? base54.consider(b.operator) : b instanceof AST_Dot && base54.consider(b.property)
        });
        this.walk(b), base54.sort()
    }), base54 = function () {
        function d() {
            c = Object.create(null), b = a.split("").map(function (a) {
                return a.charCodeAt(0)
            }), b.forEach(function (a) {
                c[a] = 0
            })
        }

        function e(a) {
            var c = "",
                d = 54;
            do c += String.fromCharCode(b[a % d]), a = Math.floor(a / d), d = 64; while (a > 0);
            return c
        }
        var b, c, a = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789";
        return e.consider = function (a) {
            var b, d;
            for (b = a.length; --b >= 0;) d = a.charCodeAt(b), d in c && ++c[d]
        }, e.sort = function () {
            b = mergeSort(b, function (a, b) {
                return is_digit(a) && !is_digit(b) ? 1 : is_digit(b) && !is_digit(a) ? -1 : c[b] - c[a]
            })
        }, e.reset = d, d(), e.get = function () {
            return b
        }, e.freq = function () {
            return c
        }, e
    }(), AST_Toplevel.DEFMETHOD("scope_warnings", function (a) {
        a = defaults(a, {
            undeclared: !1,
            unreferenced: !0,
            assign_to_global: !0,
            func_arguments: !0,
            nested_defuns: !0,
            eval: !0
        });
        var b = new TreeWalker(function (c) {
            if (a.undeclared && c instanceof AST_SymbolRef && c.undeclared() && AST_Node.warn("未声明的符号：{name} [{file}:{line},{col}]", {
                name: c.name,
                file: c.start.file,
                line: c.start.line,
                col: c.start.col
            }), a.assign_to_global) {
                var d = null;
                c instanceof AST_Assign && c.left instanceof AST_SymbolRef ? d = c.left : c instanceof AST_ForIn && c.init instanceof AST_SymbolRef && (d = c.init), d && (d.undeclared() || d.global() && d.scope !== d.definition().scope) && AST_Node.warn("{msg}: {name} [{file}:{line},{col}]", {
                    msg: d.undeclared() ? "Accidental global?" : "Assignment to global",
                    name: d.name,
                    file: d.start.file,
                    line: d.start.line,
                    col: d.start.col
                })
            }
            a.eval && c instanceof AST_SymbolRef && c.undeclared() && "eval" == c.name && AST_Node.warn("Eval 使用 [{file}:{line},{col}]", c.start), a.unreferenced && (c instanceof AST_SymbolDeclaration || c instanceof AST_Label) && c.unreferenced() && AST_Node.warn("{type} {name} 已声明但未引用 [{file}:{line},{col}]", {
                type: c instanceof AST_Label ? "Label" : "Symbol",
                name: c.name,
                file: c.start.file,
                line: c.start.line,
                col: c.start.col
            }), a.func_arguments && c instanceof AST_Lambda && c.uses_arguments && AST_Node.warn("函数 {name} [{file}:{line},{col}] 中使用的参数", {
                name: c.name ? c.name.name : "anonymous",
                file: c.start.file,
                line: c.start.line,
                col: c.start.col
            }), a.nested_defuns && c instanceof AST_Defun && !(b.parent() instanceof AST_Scope) && AST_Node.warn('嵌套语句 "{type}" 中声明的函数 {name} [{file}:{line},{col}]', {
                name: c.name.name,
                type: b.parent().TYPE,
                file: c.start.file,
                line: c.start.line,
                col: c.start.col
            })
        });
        this.walk(b)
    }), DefaultsError.prototype = Object.create(Error.prototype), DefaultsError.prototype.constructor = DefaultsError, DefaultsError.croak = function (a, b) {
        throw new DefaultsError(a, b)
    }, MAP = function () {
        function a(a, f, g) {
            function k() {
                var k = f(a[j], j),
                    l = k instanceof e;
                return l && (k = k.v), k instanceof c ? (k = k.v, k instanceof d ? i.push.apply(i, g ? k.v.slice().reverse() : k.v) : i.push(k)) : k !== b && (k instanceof d ? h.push.apply(h, g ? k.v.slice().reverse() : k.v) : h.push(k)), l
            }
            var j, h = [],
                i = [];
            if (a instanceof Array)
                if (g) {
                    for (j = a.length; --j >= 0 && !k(););
                    h.reverse(), i.reverse()
                } else
                    for (j = 0; j < a.length && !k(); ++j);
            else
                for (j in a)
                    if (a.hasOwnProperty(j) && k()) break;
            return i.concat(h)
        }

        function c(a) {
            this.v = a
        }

        function d(a) {
            this.v = a
        }

        function e(a) {
            this.v = a
        }
        a.at_top = function (a) {
            return new c(a)
        }, a.splice = function (a) {
            return new d(a)
        }, a.last = function (a) {
            return new e(a)
        };
        var b = a.skip = {};
        return a
    }(), Dictionary.prototype = {
        set: function (a, b) {
            return this.has(a) || ++this._size, this._values["$" + a] = b, this
        },
        add: function (a, b) {
            return this.has(a) ? this.get(a).push(b) : this.set(a, [b]), this
        },
        get: function (a) {
            return this._values["$" + a]
        },
        del: function (a) {
            return this.has(a) && (--this._size, delete this._values["$" + a]), this
        },
        has: function (a) {
            return "$" + a in this._values
        },
        each: function (a) {
            for (var b in this._values) a(this._values[b], b.substr(1))
        },
        size: function () {
            return this._size
        },
        map: function (a) {
            var c, b = [];
            for (c in this._values) b.push(a(this._values[c], c.substr(1)));
            return b
        }
    };
