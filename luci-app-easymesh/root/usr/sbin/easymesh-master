#!/bin/sh
# /usr/sbin/easymesh-master — EasyMesh master/agent unified daemon
#
# Election:  WAN-up node wins; fallback = lowest MAC wins
# Sync:      master serves profile on HTTP :4304/profile
#            agent polls and applies
# Channel:   scan and pick least-used (highest free-time) channel
# Backhaul:  wired detected → lower mesh0 metric, not down
# Neighbors: register peer BSSIDs from iw scan, not own interfaces
# LB:        steer only clients with signal < threshold
# Topology:  valid JSON, served on /topology

. /lib/functions.sh

ROLE_FILE="/tmp/easymesh_role"
MASTER_IP_FILE="/tmp/easymesh_master_ip"
PROFILE_FILE="/tmp/easymesh_profile.json"
TOPO_FILE="/tmp/easymesh_topo.json"
NODE_DB="/tmp/easymesh_nodes"

MESH_IF="mesh0"
AP_IF="wlan0"
RADIO_DEV="radio1"
MASTER_PORT=4304
LOG_TAG="easymesh"

LOOP_INTERVAL=10
CHANNEL_INTERVAL=120   # only re-scan every 2 min
ELECTION_INTERVAL=30

log() { logger -t "$LOG_TAG" "$*"; }

get_mac() { cat /sys/class/net/br-lan/address 2>/dev/null || cat /sys/class/net/eth0/address 2>/dev/null; }
get_ip()  { uci get network.lan.ipaddr 2>/dev/null; }

http_ok() { printf 'HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nAccess-Control-Allow-Origin: *\r\nConnection: close\r\n\r\n%s\n' "$1"; }

wan_up() {
    ubus call network.interface.wan status 2>/dev/null | grep -q '"up": true'
}

########################################
# 1. Master election
########################################
# Rule 1: WAN-up node is master
# Rule 2: no WAN anywhere → lowest MAC wins
# Anti-split: each node broadcasts its MAC+role; if two masters see each other,
#             higher MAC demotes itself

elect_role() {
    local mymac myip
    mymac=$(get_mac)
    myip=$(get_ip)

    if wan_up; then
        echo "master" > "$ROLE_FILE"
        echo "$myip"  > "$MASTER_IP_FILE"
        log "Election: WAN up → master ($mymac)"
        return
    fi

    # Probe known peers for their election status
    local best_mac="$mymac"
    local best_ip="$myip"
    mkdir -p "$NODE_DB"
    for f in "$NODE_DB"/*.json 2>/dev/null; do
        [ -f "$f" ] || continue
        local peer_ip peer_mac peer_wan
        peer_ip=$(jsonfilter -i "$f" -e '@.ip'  2>/dev/null)
        peer_mac=$(jsonfilter -i "$f" -e '@.mac' 2>/dev/null)
        peer_wan=$(wget -q -T 3 -O- "http://${peer_ip}:${MASTER_PORT}/wan" 2>/dev/null)
        # If a peer has WAN, it should be master
        echo "$peer_wan" | grep -q '"wan":true' && {
            echo "agent" > "$ROLE_FILE"
            echo "$peer_ip" > "$MASTER_IP_FILE"
            log "Election: peer $peer_ip has WAN → I am agent"
            return
        }
        # No WAN anywhere: lowest MAC wins
        [ "$peer_mac" \< "$best_mac" ] && { best_mac="$peer_mac"; best_ip="$peer_ip"; }
    done

    if [ "$best_mac" = "$mymac" ]; then
        echo "master" > "$ROLE_FILE"
        echo "$myip"  > "$MASTER_IP_FILE"
        log "Election: lowest MAC wins → master ($mymac)"
    else
        echo "agent" > "$ROLE_FILE"
        echo "$best_ip" > "$MASTER_IP_FILE"
        log "Election: $best_mac wins → I am agent"
    fi
}

role()      { cat "$ROLE_FILE"     2>/dev/null || echo "agent"; }
master_ip() { cat "$MASTER_IP_FILE" 2>/dev/null; }

########################################
# 2. Config sync
########################################

generate_profile() {
    local ssid key channel
    ssid=$(uci get wireless.@wifi-iface[0].ssid    2>/dev/null)
    key=$(uci get wireless.@wifi-iface[0].key      2>/dev/null)
    channel=$(uci get wireless.${RADIO_DEV}.channel 2>/dev/null)
    cat > "$PROFILE_FILE" <<PROF
{"ssid":"$ssid","key":"$key","channel":"$channel",
 "ieee80211k":"1","ieee80211v":"1","mesh_id":"$(uci get easymesh.global.mesh_id 2>/dev/null)"}
PROF
}

apply_profile() {
    local prof_url
    prof_url="http://$(master_ip):${MASTER_PORT}/profile"
    local body
    body=$(wget -q -T 5 -O- "$prof_url" 2>/dev/null)
    [ -z "$body" ] && return

    echo "$body" > "$PROFILE_FILE"
    local ssid key channel mesh_id
    ssid=$(jsonfilter    -i "$PROFILE_FILE" -e '@.ssid'    2>/dev/null)
    key=$(jsonfilter     -i "$PROFILE_FILE" -e '@.key'     2>/dev/null)
    channel=$(jsonfilter -i "$PROFILE_FILE" -e '@.channel' 2>/dev/null)
    mesh_id=$(jsonfilter -i "$PROFILE_FILE" -e '@.mesh_id' 2>/dev/null)

    [ -z "$ssid" ] && return

    uci set wireless.@wifi-iface[0].ssid="$ssid"
    uci set wireless.@wifi-iface[0].key="$key"
    [ -n "$channel" ] && uci set wireless.${RADIO_DEV}.channel="$channel"
    [ -n "$mesh_id" ] && uci set easymesh.global.mesh_id="$mesh_id"
    uci commit wireless
    uci commit easymesh
    wifi reload
    log "Profile applied from master: ssid=$ssid ch=$channel"
}

########################################
# 3. Channel coordination (master only)
########################################
_last_channel_scan=0

optimize_channel() {
    [ "$(role)" != "master" ] && return

    local now
    now=$(date +%s)
    [ $((now - _last_channel_scan)) -lt $CHANNEL_INTERVAL ] && return
    _last_channel_scan=$now

    # Count APs per channel; pick channel with FEWEST neighbours (least congestion)
    local best
    best=$(iw dev "$AP_IF" scan 2>/dev/null | \
        grep 'DS Parameter set' | awk '{print $5}' | \
        sort | uniq -c | sort -n | head -1 | awk '{print $2}')

    # uniq -c | sort -n → ascending by count → head -1 = least used ✓
    [ -z "$best" ] && return

    local current
    current=$(uci get wireless.${RADIO_DEV}.channel 2>/dev/null)
    if [ "$current" != "$best" ]; then
        log "Channel: $current → $best (least congested)"
        uci set wireless.${RADIO_DEV}.channel="$best"
        uci commit wireless
        wifi reload
    fi
}

########################################
# 4. Wired backhaul preference
########################################

backhaul_check() {
    local master_mac
    master_mac=$(cat "$MASTER_IP_FILE" 2>/dev/null)
    [ -z "$master_mac" ] && return

    if bridge fdb show 2>/dev/null | grep -qi "$master_mac"; then
        # Wired path to master detected → lower mesh metric so wired is preferred
        # Do NOT bring mesh0 down — that would break batman-adv for other nodes
        batctl meshif "$MESH_IF" orig_interval 5000 2>/dev/null  # reduce mesh beacon rate
        log "Backhaul: wired path active, reducing mesh overhead"
    else
        batctl meshif "$MESH_IF" orig_interval 1000 2>/dev/null
    fi
}

########################################
# 5. 802.11k/v + neighbor auto-register
########################################

enable_fast_roaming() {
    uci set wireless.@wifi-iface[0].ieee80211k='1'
    uci set wireless.@wifi-iface[0].ieee80211v='1'
    uci set wireless.@wifi-iface[0].bss_transition='1'
    uci set wireless.@wifi-iface[0].rrm_neighbor_report='1'
    uci commit wireless
    log "802.11k/v enabled"
}

register_neighbors() {
    local ssid ap_iface
    ssid=$(uci get wireless.@wifi-iface[0].ssid 2>/dev/null)
    ap_iface=$(uci get wireless.@wifi-iface[0].ifname 2>/dev/null || echo "$AP_IF")

    # Scan for PEER BSSIDs with same SSID — not own interfaces
    iw dev "$AP_IF" scan 2>/dev/null | awk '
        /^BSS /          { bssid=$2 }
        /SSID: /         { if ($2 == "'"$ssid"'") print bssid }
    ' | while read -r bssid; do
        [ -z "$bssid" ] && continue
        hostapd_cli -i "$ap_iface" set_neighbor "$bssid" ssid="\"$ssid\"" >/dev/null 2>&1 && \
            log "Registered neighbor BSSID: $bssid"
    done
}

########################################
# 6. Load balancing (signal-aware)
########################################
LB_THRESHOLD=-70   # dBm; only steer clients weaker than this

load_balance() {
    local ap_iface
    ap_iface=$(uci get wireless.@wifi-iface[0].ifname 2>/dev/null || echo "$AP_IF")
    local clients
    clients=$(iw dev "$ap_iface" station dump 2>/dev/null | grep -c "^Station")
    [ "$clients" -le 10 ] && return   # no balancing needed under 10 clients

    # Only steer clients with signal below threshold
    iw dev "$ap_iface" station dump 2>/dev/null | awk '
        /^Station/  { mac=$2 }
        /signal:/   { if ($2+0 < '"$LB_THRESHOLD"') print mac }
    ' | while read -r mac; do
        [ -z "$mac" ] && continue
        hostapd_cli -i "$ap_iface" bss_tm_req "$mac" pref=1 abridged=1 >/dev/null 2>&1 && \
            log "BSS-TM steered weak client: $mac (signal < ${LB_THRESHOLD}dBm)"
    done
}

########################################
# 7. Topology JSON
########################################

update_topology() {
    local my_mac my_ip my_role clients
    my_mac=$(get_mac)
    my_ip=$(get_ip)
    my_role=$(role)
    clients=$(iw dev "$AP_IF" station dump 2>/dev/null | grep -c "^Station")

    # Build nodes array from bat0 originators
    local nodes="{\"mac\":\"$my_mac\",\"ip\":\"$my_ip\",\"role\":\"$my_role\",\"clients\":$clients}"
    local links=""

    while read -r peer_mac _ tq _rest; do
        nodes="${nodes},{\"mac\":\"$peer_mac\",\"tq\":$tq}"
        links="${links:+$links,}{\"src\":\"$my_mac\",\"dst\":\"$peer_mac\",\"tq\":$tq}"
    done < <(awk 'NR>2 {print $1,$2,$3}' /sys/kernel/debug/batman_adv/bat0/originators 2>/dev/null)

    printf '{"ts":%d,"nodes":[%s],"links":[%s]}\n' \
        "$(date +%s)" "$nodes" "$links" > "$TOPO_FILE"
}

########################################
# HTTP handler (single-port: 4304)
########################################

handle_request() {
    local req="$1"
    local path
    path=$(awk 'NR==1{print $2}' "$req" 2>/dev/null)
    path="${path%%\?*}"

    case "$path" in
        /profile)   http_ok "$(cat "$PROFILE_FILE" 2>/dev/null || echo '{}')" ;;
        /topology)  update_topology; http_ok "$(cat "$TOPO_FILE")" ;;
        /wan)       wan_up && http_ok '{"wan":true}' || http_ok '{"wan":false}' ;;
        /info)
            http_ok "{\"mac\":\"$(get_mac)\",\"ip\":\"$(get_ip)\",\"role\":\"$(role)\"}"
            ;;
        /easymesh/generate-qr)
            http_ok "$(/usr/sbin/easymesh-qr generate 2>/dev/null || echo '{}')" ;;
        /easymesh/qr-config*)
            local token
            token=$(awk -F'token=' '{print $2}' "$req" | cut -d'&' -f1 | head -1)
            http_ok "$(/usr/sbin/easymesh-qr verify "$token" 2>/dev/null || echo '{"status":"invalid"}')" ;;
        /easymesh/nodes)
            local out="["
            local first=1
            for f in "$NODE_DB"/*.json 2>/dev/null; do
                [ -f "$f" ] || continue
                [ "$first" = "0" ] && out="${out},"
                out="${out}$(cat "$f")"
                first=0
            done
            http_ok "${out}]" ;;
        *) printf 'HTTP/1.1 404 Not Found\r\nConnection: close\r\n\r\n' ;;
    esac
}

run_server() {
    log "HTTP server on :$MASTER_PORT"
    while true; do
        local tmp="/tmp/em_req_$$"
        nc -l -p "$MASTER_PORT" > "$tmp" 2>/dev/null
        handle_request "$tmp" | nc -l -p "$MASTER_PORT" 2>/dev/null &
        rm -f "$tmp"
        sleep 0.05
    done
}

########################################
# Main loop
########################################

main_loop() {
    enable_fast_roaming
    mkdir -p "$NODE_DB"
    run_server &

    local _iter=0
    while true; do
        elect_role

        if [ "$(role)" = "master" ]; then
            generate_profile
            optimize_channel
        else
            apply_profile
        fi

        backhaul_check
        register_neighbors
        load_balance
        update_topology

        _iter=$((_iter + 1))
        sleep $LOOP_INTERVAL
    done
}

case "$1" in
    start)  main_loop & ;;
    stop)   kill "$(cat /tmp/easymesh_master.pid 2>/dev/null)" 2>/dev/null ;;
    *)      main_loop ;;
esac
