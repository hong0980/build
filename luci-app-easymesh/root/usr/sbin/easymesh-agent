#!/bin/sh
# /usr/sbin/easymesh-agent
# 从节点自动配对守护进程
#
# 流程：
#   1. 扫描周围 WiFi，寻找 "EasyMesh-Pairing" 临时配对网络
#   2. 连接后自动获取 DHCP IP
#   3. 向主节点发送配对请求（携带本机 hostname/MAC）
#   4. 轮询等待主节点用户在 LuCI 点击"确认加入"
#   5. 收到配置后写入 UCI，重启服务，配对完成
#
# 从节点无需任何预置配置，刷完 OpenWrt 上电即可自动运行。

PAIRING_SSID="EasyMesh-Pairing"   # 与主节点 easymesh-master 约定的固定配对 SSID
PAIRING_IFACE="wlan0"             # 用于配对的无线接口（临时 STA 模式）
PAIRING_BRIDGE="br-easymesh-pair" # 临时桥接口
MASTER_PORT=4304
TOKEN_FILE="/etc/easymesh_pair.token"
STATE_FILE="/tmp/easymesh_agent.state"
LOG_TAG="easymesh-agent"
SCAN_INTERVAL=8
POLL_INTERVAL=5
PAIR_TIMEOUT=300

log() { logger -t "$LOG_TAG" "$*"; echo "[$(date '+%H:%M:%S')] [agent] $*"; }
set_state() { echo "$1" > "$STATE_FILE"; log "-> 状态: $1"; }

# ── Token（基于MAC，重启不变）──────────────────
get_token() {
    [ -f "$TOKEN_FILE" ] && { cat "$TOKEN_FILE"; return; }
    local mac
    mac=$(cat /sys/class/net/wlan0/address 2>/dev/null || \
          cat /sys/class/net/eth0/address  2>/dev/null || \
          cat /proc/sys/kernel/random/uuid 2>/dev/null | head -c 12)
    printf '%s' "$mac" | md5sum | cut -c1-16 > "$TOKEN_FILE"
    cat "$TOKEN_FILE"
}

# ── 本机信息（用于主节点 LuCI 展示）─────────────
get_self_info() {
    local mac hostname
    mac=$(cat /sys/class/net/wlan0/address 2>/dev/null || \
          cat /sys/class/net/eth0/address  2>/dev/null || echo "unknown")
    hostname=$(uci get system.@system[0].hostname 2>/dev/null || \
               cat /proc/sys/kernel/hostname 2>/dev/null || echo "OpenWrt")
    printf '{"mac":"%s","hostname":"%s"}' "$mac" "$hostname"
}

# ── 找到第一个可用的无线radio ─────────────────
get_wifi_iface() {
    # 找物理无线接口（不是已配置的 AP）
    for iface in wlan0 wlan1 phy0-ap0 phy1-ap0; do
        [ -d "/sys/class/net/$iface" ] && echo "$iface" && return
    done
    # 通过 iw 枚举
    iw dev 2>/dev/null | awk '/Interface/{print $2}' | head -1
}

# ── 创建临时 STA 接口连接配对 SSID ────────────
connect_pairing_ssid() {
    local radio iface

    # 找到可用的 phy（物理无线设备）
    local phy
    phy=$(iw phy 2>/dev/null | awk '/^phy/{print $1}' | head -1)
    [ -z "$phy" ] && { log "错误：找不到无线硬件"; return 1; }

    PAIRING_IFACE="mesh-pair0"

    # 创建临时 managed（STA）模式接口
    iw phy "$phy" interface add "$PAIRING_IFACE" type managed 2>/dev/null || {
        # 如果已存在就直接用
        ip link set "$PAIRING_IFACE" up 2>/dev/null || {
            log "无法创建配对接口"; return 1
        }
    }

    ip link set "$PAIRING_IFACE" up

    # 用 wpa_supplicant 连接（无密码开放网络）
    local wpa_conf="/tmp/easymesh_pair_wpa.conf"
    cat > "$wpa_conf" << WPAEOF
ctrl_interface=/var/run/wpa_supplicant
network={
    ssid="$PAIRING_SSID"
    key_mgmt=NONE
    priority=100
}
WPAEOF

    log "尝试连接配对网络 SSID: $PAIRING_SSID"
    wpa_supplicant -B -i "$PAIRING_IFACE" -c "$wpa_conf" -P /tmp/easymesh_wpa.pid 2>/dev/null

    # 等待连接成功（最多20秒）
    local elapsed=0
    while [ "$elapsed" -lt 20 ]; do
        local status
        status=$(wpa_cli -i "$PAIRING_IFACE" status 2>/dev/null | grep 'wpa_state' | cut -d= -f2)
        if [ "$status" = "COMPLETED" ]; then
            log "已连接到 $PAIRING_SSID"
            # 通过 udhcpc 获取 IP
            udhcpc -i "$PAIRING_IFACE" -t 10 -T 3 -n -q 2>/dev/null &
            sleep 5
            return 0
        fi
        sleep 2
        elapsed=$((elapsed + 2))
    done

    log "连接 $PAIRING_SSID 超时"
    cleanup_pairing_iface
    return 1
}

# ── 清理临时配对接口 ──────────────────────────
cleanup_pairing_iface() {
    kill "$(cat /tmp/easymesh_wpa.pid 2>/dev/null)" 2>/dev/null
    iw dev "$PAIRING_IFACE" del 2>/dev/null
    rm -f /tmp/easymesh_pair_wpa.conf /tmp/easymesh_wpa.pid
}

# ── 获取通过配对接口拿到的网关 IP ─────────────
get_pairing_gateway() {
    ip -4 route show dev "$PAIRING_IFACE" 2>/dev/null | awk '/default/{print $3}' | head -1
    # fallback：从 udhcpc 获得的路由
    [ -z "$gw" ] && ip -4 route show default 2>/dev/null | awk '{print $3}' | head -1
}

# ── 确认是 easymesh-master ────────────────────
ping_master() {
    local gw="$1"
    local resp
    resp=$(wget -q -T 4 -O- "http://${gw}:${MASTER_PORT}/easymesh/ping" 2>/dev/null)
    echo "$resp" | grep -q '"easymesh_master"'
}

# ── 发送配对请求 ──────────────────────────────
do_pair() {
    local gw="$1"
    local token body resp
    token=$(get_token)
    body=$(printf '{"token":"%s","node":%s}' "$token" "$(get_self_info)")

    resp=$(wget -q -T 8 -O- \
        --post-data="$body" \
        --header='Content-Type: application/json' \
        "http://${gw}:${MASTER_PORT}/easymesh/pair" 2>/dev/null)

    if echo "$resp" | grep -q '"status":"approved"'; then
        apply_config "$gw" "$resp"
        return 2
    elif echo "$resp" | grep -q '"status":"pending"'; then
        log "等待主节点用户确认..."
        return 0
    fi
    log "配对请求失败: $resp"
    return 1
}

# ── 轮询配置 ─────────────────────────────────
poll_for_config() {
    local gw="$1"
    local token elapsed=0
    token=$(get_token)

    while [ "$elapsed" -lt "$PAIR_TIMEOUT" ]; do
        local resp
        resp=$(wget -q -T 5 -O- \
            "http://${gw}:${MASTER_PORT}/easymesh/config?token=${token}" 2>/dev/null)
        if echo "$resp" | grep -q '"status":"approved"'; then
            apply_config "$gw" "$resp"
            return 0
        fi
        sleep "$POLL_INTERVAL"
        elapsed=$((elapsed + POLL_INTERVAL))
        [ $((elapsed % 30)) -eq 0 ] && log "等待主节点确认... ${elapsed}s/${PAIR_TIMEOUT}s"
    done

    log "等待超时，重新扫描"
    return 1
}

# ── 解析 JSON 字段 ────────────────────────────
json_get() { echo "$1" | grep -o "\"${2}\":\"[^\"]*\"" | head -1 | cut -d'"' -f4; }

# ── 应用配置并重启 ────────────────────────────
apply_config() {
    local gw="$1" resp="$2"

    local mesh_id mesh_key ssid wifi_key mobility_domain
    local ieee80211r ieee80211k ieee80211v mesh_band routing_algo
    mesh_id=$(json_get "$resp" mesh_id)
    mesh_key=$(json_get "$resp" mesh_key)
    ssid=$(json_get "$resp" ssid)
    wifi_key=$(json_get "$resp" wifi_key)
    mobility_domain=$(json_get "$resp" mobility_domain)
    ieee80211r=$(json_get "$resp" ieee80211r)
    ieee80211k=$(json_get "$resp" ieee80211k)
    ieee80211v=$(json_get "$resp" ieee80211v)
    mesh_band=$(json_get "$resp" mesh_band)
    routing_algo=$(json_get "$resp" routing_algo)

    [ -z "$mesh_id" ] && { log "错误：响应缺少 mesh_id"; return 1; }

    log "应用配置: ssid=$ssid mesh_id=$mesh_id"

    uci batch << UCIEOF
set easymesh.global.enabled=1
set easymesh.global.role=slave
set easymesh.global.mesh_id=$mesh_id
set easymesh.global.mesh_key=$mesh_key
set easymesh.global.ssid=$ssid
set easymesh.global.key=$wifi_key
set easymesh.global.mobility_domain=${mobility_domain:-aabb}
set easymesh.global.ieee80211r=${ieee80211r:-1}
set easymesh.global.ieee80211k=${ieee80211k:-1}
set easymesh.global.ieee80211v=${ieee80211v:-1}
set easymesh.global.mesh_band=${mesh_band:-5g}
set easymesh.global.routing_algo=${routing_algo:-BATMAN_IV}
set easymesh.global.backhaul=wireless
commit easymesh
UCIEOF

    set_state "configured"

    # 通知主节点完成
    local token
    token=$(get_token)
    wget -q -T 5 -O/dev/null \
        "http://${gw}:${MASTER_PORT}/easymesh/confirm?token=${token}" 2>/dev/null

    log "配置写入完成，清理配对接口后重启服务..."
    cleanup_pairing_iface
    sleep 2
    /etc/init.d/easymesh restart
}

# ── 主循环 ────────────────────────────────────
main() {
    log "EasyMesh Agent 启动"

    [ "$(uci get easymesh.global.enabled 2>/dev/null)" = "1" ] && {
        log "已完成配置，agent 退出"
        exit 0
    }

    set_state "scanning"

    while true; do
        log "扫描配对网络 '$PAIRING_SSID'..."

        # 先用 iw 扫描确认目标 SSID 在空气中存在，避免无谓连接
        local found_ssid
        found_ssid=$(iw dev 2>/dev/null | awk '/Interface/{print $2}' | head -1)
        [ -n "$found_ssid" ] && \
            iw dev "$found_ssid" scan 2>/dev/null | grep -q "\"$PAIRING_SSID\"" || {
            log "未扫描到 '$PAIRING_SSID'，请确认主节点已开启配对模式，${SCAN_INTERVAL}s 后重试..."
            sleep "$SCAN_INTERVAL"
            continue
        }

        log "发现配对网络，尝试连接..."
        if ! connect_pairing_ssid; then
            sleep "$SCAN_INTERVAL"
            continue
        fi

        local gw
        gw=$(get_pairing_gateway)
        if [ -z "$gw" ]; then
            log "未获取到网关 IP，${SCAN_INTERVAL}s 后重试..."
            cleanup_pairing_iface
            sleep "$SCAN_INTERVAL"
            continue
        fi

        log "网关: $gw，确认是否为 easymesh-master..."
        if ! ping_master "$gw"; then
            log "网关未运行 easymesh-master"
            cleanup_pairing_iface
            sleep "$SCAN_INTERVAL"
            continue
        fi

        set_state "pairing"
        local result
        do_pair "$gw"
        result=$?

        [ "$result" -eq 2 ] && break   # 直接完成
        [ "$result" -eq 0 ] && {
            set_state "waiting_confirm"
            poll_for_config "$gw" && break
        }

        cleanup_pairing_iface
        set_state "scanning"
        sleep "$SCAN_INTERVAL"
    done
}

main "$@"
